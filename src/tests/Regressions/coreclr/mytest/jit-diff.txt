****** START compiling System.Runtime.Intrinsics.X86.Program:Main(System.String[]) (MethodHash=1e684c7a)
Generating code for Windows x64
OPTIONS: compCodeOpt = BLENDED_CODE
OPTIONS: compDbgCode = true
OPTIONS: compDbgInfo = true
OPTIONS: compDbgEnC  = false
OPTIONS: compProcedureSplitting   = false
OPTIONS: compProcedureSplittingEH = false
OPTIONS: optimizer should use profile data
IL to import:
IL_0000  00                nop         
IL_0001  72 01 00 00 70    ldstr        0x70000001
IL_0006  0a                stloc.0     
IL_0007  19                ldc.i4.3    
IL_0008  8d 0e 00 00 01    newarr       0x100000E
IL_000d  25                dup         
IL_000e  d0 01 00 00 04    ldtoken      0x4000001
IL_0013  28 0a 00 00 0a    call         0xA00000A
IL_0018  0b                stloc.1     
IL_0019  06                ldloc.0     
IL_001a  07                ldloc.1     
IL_001b  17                ldc.i4.1    
IL_001c  28 01 00 00 06    call         0x6000001
IL_0021  26                pop         
IL_0022  2a                ret         

lvaSetClass: setting class for V00 to (00007FFD106134A8) System.String[] 
Arg #0    passed in register(s) rcx

lvaSetClass: setting class for V01 to (00007FFD10492470) System.String 

lvaSetClass: setting class for V02 to (00007FFD107D1A48) ushort[] 

lvaGrabTemp returning 3 (V03 tmp0) (a long lifetime temp) called for OutgoingArgSpace.

Local V03 should not be enregistered because: it is address exposed
; Initial local variable assignments
;
;  V00 arg0              ref  class-hnd <System.String[]>
;  V01 loc0              ref  class-hnd <System.String>
;  V02 loc1              ref  class-hnd <ushort[]>
;  V03 OutArgs        struct <0> do-not-enreg[XS] addr-exposed "OutgoingArgSpace"
*************** In compInitDebuggingInfo() for System.Runtime.Intrinsics.X86.Program:Main(System.String[])
getVars() returned cVars = 0, extendOthers = true
info.compVarScopesCount = 3
    	VarNum 	LVNum 	      Name 	Beg 	End
 0: 	00h 	00h 	  V00 arg0 	000h   	023h
 1: 	01h 	01h 	  V01 loc0 	000h   	023h
 2: 	02h 	02h 	  V02 loc1 	000h   	023h
New Basic Block BB01 [0000] created.
New scratch BB01
Debuggable code - Add new BB01 [0000] to perform initialization of variables
info.compStmtOffsetsCount    = 0
info.compStmtOffsetsImplicit = 0007h ( STACK_EMPTY NOP CALL_SITE )
*************** In fgFindBasicBlocks() for System.Runtime.Intrinsics.X86.Program:Main(System.String[])
Marked V01 as a single def local
Marked V02 as a single def local
Jump targets:
  none
New Basic Block BB02 [0001] created.
BB02 [000..023)
Setting edge weights for BB01 -> BB02 to [0 .. 3.402823e+38]
CLFLG_MINOPT set for method System.Runtime.Intrinsics.X86.Program:Main(System.String[])
IL Code Size,Instr   35,  15, Basic Block count   2, Local Variable Num,Ref count   4,  4 for method System.Runtime.Intrinsics.X86.Program:Main(System.String[])
IL Code Size,Instr   35,  15, Basic Block count   2, Local Variable Num,Ref count   4,  4 for method System.Runtime.Intrinsics.X86.Program:Main(System.String[])
OPTIONS: opts.MinOpts() == true
Basic block list for 'System.Runtime.Intrinsics.X86.Program:Main(System.String[])'

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal 
BB02 [0001]  1       BB01                  1       [000..023)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Pre-import

*************** Finishing PHASE Pre-import
Trees after Pre-import

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal 
BB02 [0001]  1       BB01                  1       [000..023)        (return)                     
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----------                         *  NOP       void  

------------ BB02 [000..023) (return), preds={BB01} succs={}

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist

*************** Starting PHASE Profile incorporation
BBOPT set, but no profile data available (hr=80004001)

*************** Finishing PHASE Profile incorporation [no changes]

*************** Starting PHASE Importation
Marking leading BBF_INTERNAL block BB01 as BBF_IMPORTED

impImportBlockPending for BB02

Importing BB02 (PC=000) of 'System.Runtime.Intrinsics.X86.Program:Main(System.String[])'
    [ 0]   0 (0x000) nop

STMT00001 ( 0x000[E-] ... ??? )
               [000001] -----------                         *  NO_OP     void  

    [ 0]   1 (0x001) ldstr 70000001
    [ 1]   6 (0x006) stloc.0
lvaUpdateClass: Updating class for V01 from (00007FFD10492470) System.String to (00007FFD10492470) System.String [exact]


STMT00002 ( 0x001[E-] ... ??? )
               [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
               [000002] -----------                         \--*  CNS_STR   ref   <string constant>

    [ 0]   7 (0x007) ldc.i4.3 3
    [ 1]   8 (0x008) newarr 0100000E
lvaGrabTemp returning 4 (V04 tmp1) called for impSpillStackEnsure.


STMT00003 ( 0x007[E-] ... ??? )
               [000007] DACXG------                         *  STORE_LCL_VAR ref    V04 tmp1         
               [000006] --CXG------                         \--*  CALL help ref    CORINFO_HELP_NEWARR_1_VC
               [000005] H---------- arg0                       +--*  CNS_INT(h) long   0x7ffd107d1a48 class
               [000004] ----------- arg1                       \--*  CNS_INT   long   3
Marked V04 as a single def temp

lvaSetClass: setting class for V04 to (00007FFD107D1A48) ushort[]  [exact]

    [ 1]  13 (0x00d) dup
    [ 2]  14 (0x00e) ldtoken
    [ 3]  19 (0x013) call 0A00000A
In Compiler::impImportCall: opcode is call, kind=0, callRetType is void, structSize is 0
Named Intrinsic System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray: Recognized
Calling impNormStructVal on:
               [000011] --CXG------                         *  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
               [000010] H---------- arg0                    \--*  CNS_INT(h) long   0x7ffd107d1db0 field

lvaGrabTemp returning 5 (V05 tmp2) called for spilled call-like call argument.


STMT00004 ( 0x00D[--] ... ??? )
               [000013] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
               [000011] --CXG------                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
               [000010] H---------- arg0                       \--*  CNS_INT(h) long   0x7ffd107d1db0 field
resulting tree:
               [000014] -----------                         *  LCL_VAR   struct<System.RuntimeFieldHandle, 8> V05 tmp2         


STMT00005 ( ??? ... ??? )
               [000012] --C-G------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000009] ----------- arg0                    +--*  LCL_VAR   ref    V04 tmp1         
               [000014] ----------- arg1                    \--*  LCL_VAR   struct<System.RuntimeFieldHandle, 8> V05 tmp2         

    [ 1]  24 (0x018) stloc.1
lvaUpdateClass: Updating class for V02 from (00007FFD107D1A48) ushort[] to (00007FFD107D1A48) ushort[] [exact]


STMT00006 ( 0x018[--] ... ??? )
               [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
               [000008] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

    [ 0]  25 (0x019) ldloc.0
    [ 1]  26 (0x01a) ldloc.1
    [ 2]  27 (0x01b) ldc.i4.1 1
    [ 3]  28 (0x01c) call 06000001
In Compiler::impImportCall: opcode is call, kind=0, callRetType is ref, structSize is 0

lvaGrabTemp returning 6 (V06 tmp3) called for impSpillStackEnsure.


STMT00007 ( 0x019[E-] ... ??? )
               [000020] DAC-G------                         *  STORE_LCL_VAR ref    V06 tmp3         
               [000019] --C-G------                         \--*  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
               [000016] ----------- arg0                       +--*  LCL_VAR   ref    V01 loc0         
               [000017] ----------- arg1                       +--*  LCL_VAR   ref    V02 loc1         
               [000018] ----------- arg2                       \--*  CNS_INT   int    1
Marked V06 as a single def temp

lvaSetClass: setting class for V06 to (00007FFD106134A8) System.String[]  [exact]

    [ 1]  33 (0x021) pop

STMT00008 ( 0x021[--] ... ??? )
               [000022] -----------                         *  NOP       void  

    [ 0]  34 (0x022) ret

STMT00009 ( 0x022[E-] ... ??? )
               [000023] -----------                         *  RETURN    void  

*************** Finishing PHASE Importation
Trees after Importation

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal 
BB02 [0001]  1       BB01                  1       [000..023)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----------                         *  NOP       void  

------------ BB02 [000..023) (return), preds={BB01} succs={}

***** BB02
STMT00001 ( 0x000[E-] ... 0x000 )
               [000001] -----------                         *  NO_OP     void  

***** BB02
STMT00002 ( 0x001[E-] ... 0x006 )
               [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
               [000002] -----------                         \--*  CNS_STR   ref   <string constant>

***** BB02
STMT00003 ( 0x007[E-] ... 0x018 )
               [000007] DACXG------                         *  STORE_LCL_VAR ref    V04 tmp1         
               [000006] --CXG------                         \--*  CALL help ref    CORINFO_HELP_NEWARR_1_VC
               [000005] H---------- arg0                       +--*  CNS_INT(h) long   0x7ffd107d1a48 class
               [000004] ----------- arg1                       \--*  CNS_INT   long   3

***** BB02
STMT00004 ( 0x00D[--] ... ??? )
               [000013] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
               [000011] --CXG------                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
               [000010] H---------- arg0                       \--*  CNS_INT(h) long   0x7ffd107d1db0 field

***** BB02
STMT00005 ( ??? ... ??? )
               [000012] --C-G------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000009] ----------- arg0                    +--*  LCL_VAR   ref    V04 tmp1         
               [000014] ----------- arg1                    \--*  LCL_VAR   struct<System.RuntimeFieldHandle, 8> V05 tmp2         

***** BB02
STMT00006 ( 0x018[--] ... ??? )
               [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
               [000008] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

***** BB02
STMT00007 ( 0x019[E-] ... 0x021 )
               [000020] DAC-G------                         *  STORE_LCL_VAR ref    V06 tmp3         
               [000019] --C-G------                         \--*  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
               [000016] ----------- arg0                       +--*  LCL_VAR   ref    V01 loc0         
               [000017] ----------- arg1                       +--*  LCL_VAR   ref    V02 loc1         
               [000018] ----------- arg2                       \--*  CNS_INT   int    1

***** BB02
STMT00008 ( 0x021[--] ... ??? )
               [000022] -----------                         *  NOP       void  

***** BB02
STMT00009 ( 0x022[E-] ... 0x022 )
               [000023] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
*************** In fgDebugCheckLoopTable: loop table not valid

*************** Starting PHASE Expand patchpoints

 -- no patchpoints to transform

*************** Finishing PHASE Expand patchpoints [no changes]

*************** Starting PHASE Indirect call transform

 -- no candidates to transform

*************** Finishing PHASE Indirect call transform [no changes]

*************** Starting PHASE Post-import

*************** Finishing PHASE Post-import [no changes]

*************** Starting PHASE Morph - Init

New BlockSet epoch 1, # of blocks (including unused BB00): 3, bitset array size: 1 (short)

*************** Finishing PHASE Morph - Init [no changes]

*************** Starting PHASE Morph - Inlining

*************** Finishing PHASE Morph - Inlining [no changes]

*************** Starting PHASE Allocate Objects
no newobjs in this method; punting

*************** Finishing PHASE Allocate Objects [no changes]

*************** Starting PHASE Morph - Add internal blocks

*************** After fgAddInternal()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal 
BB02 [0001]  1       BB01                  1       [000..023)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty

*************** Finishing PHASE Morph - Add internal blocks
Trees after Morph - Add internal blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal 
BB02 [0001]  1       BB01                  1       [000..023)        (return)                     i 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----------                         *  NOP       void  

***** BB01
STMT00010 ( ??? ... ??? )
               [000031] --C-G------                         *  QMARK     void  
               [000027] ----G------    if                   +--*  EQ        int   
               [000025] n---G------                         |  +--*  IND       int   
               [000024] H----------                         |  |  \--*  CNS_INT(h) long   0x7ffd10611d48 global ptr
               [000026] -----------                         |  \--*  CNS_INT   int    0
               [000030] --C-G------    if                   \--*  COLON     void  
               [000028] --C-G------ else                       +--*  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE
               [000029] ----------- then                       \--*  NOP       void  

------------ BB02 [000..023) (return), preds={BB01} succs={}

***** BB02
STMT00001 ( 0x000[E-] ... 0x000 )
               [000001] -----------                         *  NO_OP     void  

***** BB02
STMT00002 ( 0x001[E-] ... 0x006 )
               [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
               [000002] -----------                         \--*  CNS_STR   ref   <string constant>

***** BB02
STMT00003 ( 0x007[E-] ... 0x018 )
               [000007] DACXG------                         *  STORE_LCL_VAR ref    V04 tmp1         
               [000006] --CXG------                         \--*  CALL help ref    CORINFO_HELP_NEWARR_1_VC
               [000005] H---------- arg0                       +--*  CNS_INT(h) long   0x7ffd107d1a48 class
               [000004] ----------- arg1                       \--*  CNS_INT   long   3

***** BB02
STMT00004 ( 0x00D[--] ... ??? )
               [000013] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
               [000011] --CXG------                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
               [000010] H---------- arg0                       \--*  CNS_INT(h) long   0x7ffd107d1db0 field

***** BB02
STMT00005 ( ??? ... ??? )
               [000012] --C-G------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000009] ----------- arg0                    +--*  LCL_VAR   ref    V04 tmp1         
               [000014] ----------- arg1                    \--*  LCL_VAR   struct<System.RuntimeFieldHandle, 8> V05 tmp2         

***** BB02
STMT00006 ( 0x018[--] ... ??? )
               [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
               [000008] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

***** BB02
STMT00007 ( 0x019[E-] ... 0x021 )
               [000020] DAC-G------                         *  STORE_LCL_VAR ref    V06 tmp3         
               [000019] --C-G------                         \--*  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
               [000016] ----------- arg0                       +--*  LCL_VAR   ref    V01 loc0         
               [000017] ----------- arg1                       +--*  LCL_VAR   ref    V02 loc1         
               [000018] ----------- arg2                       \--*  CNS_INT   int    1

***** BB02
STMT00008 ( 0x021[--] ... ??? )
               [000022] -----------                         *  NOP       void  

***** BB02
STMT00009 ( 0x022[E-] ... 0x022 )
               [000023] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
*************** In fgDebugCheckLoopTable: loop table not valid

*************** Starting PHASE Remove empty try

*************** In fgRemoveEmptyTry()
No EH in this method, nothing to remove.

*************** Finishing PHASE Remove empty try [no changes]

*************** Starting PHASE Remove empty finally
No EH in this method, nothing to remove.

*************** Finishing PHASE Remove empty finally [no changes]

*************** Starting PHASE Merge callfinally chains
No EH in this method, nothing to merge.

*************** Finishing PHASE Merge callfinally chains [no changes]

*************** Starting PHASE Clone finally
No EH in this method, no cloning.

*************** Finishing PHASE Clone finally [no changes]

*************** Starting PHASE Morph - Promote Structs
  promotion opt flag not enabled

*************** Finishing PHASE Morph - Promote Structs [no changes]

*************** Starting PHASE Morph - Structs/AddrExp
LocalAddressVisitor visiting statement:
STMT00000 ( ??? ... ??? )
               [000000] -----------                         *  NOP       void  

LocalAddressVisitor visiting statement:
STMT00010 ( ??? ... ??? )
               [000031] --C-G------                         *  QMARK     void  
               [000027] ----G------    if                   +--*  EQ        int   
               [000025] n---G------                         |  +--*  IND       int   
               [000024] H----------                         |  |  \--*  CNS_INT(h) long   0x7ffd10611d48 global ptr
               [000026] -----------                         |  \--*  CNS_INT   int    0
               [000030] --C-G------    if                   \--*  COLON     void  
               [000028] --C-G------ else                       +--*  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE
               [000029] ----------- then                       \--*  NOP       void  

LocalAddressVisitor visiting statement:
STMT00001 ( 0x000[E-] ... 0x000 )
               [000001] -----------                         *  NO_OP     void  

LocalAddressVisitor visiting statement:
STMT00002 ( 0x001[E-] ... 0x006 )
               [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
               [000002] -----------                         \--*  CNS_STR   ref   <string constant>

LocalAddressVisitor visiting statement:
STMT00003 ( 0x007[E-] ... 0x018 )
               [000007] DACXG------                         *  STORE_LCL_VAR ref    V04 tmp1         
               [000006] --CXG------                         \--*  CALL help ref    CORINFO_HELP_NEWARR_1_VC
               [000005] H---------- arg0                       +--*  CNS_INT(h) long   0x7ffd107d1a48 class
               [000004] ----------- arg1                       \--*  CNS_INT   long   3

LocalAddressVisitor visiting statement:
STMT00004 ( 0x00D[--] ... ??? )
               [000013] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
               [000011] --CXG------                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
               [000010] H---------- arg0                       \--*  CNS_INT(h) long   0x7ffd107d1db0 field

LocalAddressVisitor visiting statement:
STMT00005 ( ??? ... ??? )
               [000012] --C-G------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000009] ----------- arg0                    +--*  LCL_VAR   ref    V04 tmp1         
               [000014] ----------- arg1                    \--*  LCL_VAR   struct<System.RuntimeFieldHandle, 8> V05 tmp2         

LocalAddressVisitor visiting statement:
STMT00006 ( 0x018[--] ... ??? )
               [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
               [000008] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

LocalAddressVisitor visiting statement:
STMT00007 ( 0x019[E-] ... 0x021 )
               [000020] DAC-G------                         *  STORE_LCL_VAR ref    V06 tmp3         
               [000019] --C-G------                         \--*  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
               [000016] ----------- arg0                       +--*  LCL_VAR   ref    V01 loc0         
               [000017] ----------- arg1                       +--*  LCL_VAR   ref    V02 loc1         
               [000018] ----------- arg2                       \--*  CNS_INT   int    1

LocalAddressVisitor visiting statement:
STMT00008 ( 0x021[--] ... ??? )
               [000022] -----------                         *  NOP       void  

LocalAddressVisitor visiting statement:
STMT00009 ( 0x022[E-] ... 0x022 )
               [000023] -----------                         *  RETURN    void  


*************** Finishing PHASE Morph - Structs/AddrExp [no changes]

*************** Starting PHASE Early liveness

*************** Finishing PHASE Early liveness [no changes]

*************** Starting PHASE Forward Substitution

*************** Finishing PHASE Forward Substitution [no changes]

*************** Starting PHASE Physical promotion

*************** Finishing PHASE Physical promotion [no changes]

*************** Starting PHASE Identify candidates for implicit byref copy omission

*************** Finishing PHASE Identify candidates for implicit byref copy omission [no changes]

*************** Starting PHASE Morph - ByRefs

*************** Finishing PHASE Morph - ByRefs [no changes]

*************** Starting PHASE Morph - Global

*************** In fgMorphBlocks()
compEnregLocals() is false, setting doNotEnreg flag for all locals.
Local V00 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V01 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V02 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V03 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V04 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V05 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V06 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Morphing BB01 of 'System.Runtime.Intrinsics.X86.Program:Main(System.String[])'

fgMorphTree BB01, STMT00000 (before)
               [000000] -----------                         *  NOP       void  

fgMorphTree BB01, STMT00010 (before)
               [000031] --C-G------                         *  QMARK     void  
               [000027] ----G------    if                   +--*  EQ        int   
               [000025] n---G------                         |  +--*  IND       int   
               [000024] H----------                         |  |  \--*  CNS_INT(h) long   0x7ffd10611d48 global ptr
               [000026] -----------                         |  \--*  CNS_INT   int    0
               [000030] --C-G------    if                   \--*  COLON     void  
               [000028] --C-G------ else                       +--*  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE
               [000029] ----------- then                       \--*  NOP       void  
Initializing arg info for 28.CALL:
Args for call [000028] CALL after AddFinalArgsAndDetermineABIInfo:

Morphing args for 28.CALL:
Args for [000028].CALL after fgMorphArgs:
OutgoingArgsStackSize is 32


Morphing BB02 of 'System.Runtime.Intrinsics.X86.Program:Main(System.String[])'

fgMorphTree BB02, STMT00001 (before)
               [000001] -----------                         *  NO_OP     void  

fgMorphTree BB02, STMT00002 (before)
               [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
               [000002] -----------                         \--*  CNS_STR   ref   <string constant>

fgMorphTree BB02, STMT00002 (after)
               [000003] DA---+-----                         *  STORE_LCL_VAR ref    V01 loc0         
               [000032] H----+-----                         \--*  CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '


fgMorphTree BB02, STMT00003 (before)
               [000007] DACXG------                         *  STORE_LCL_VAR ref    V04 tmp1         
               [000006] --CXG------                         \--*  CALL help ref    CORINFO_HELP_NEWARR_1_VC
               [000005] H---------- arg0                       +--*  CNS_INT(h) long   0x7ffd107d1a48 class
               [000004] ----------- arg1                       \--*  CNS_INT   long   3
Initializing arg info for 6.CALL:
Args for call [000006] CALL after AddFinalArgsAndDetermineABIInfo:
CallArg[[000005].CNS_INT long (By value), 1 reg: rcx, byteAlignment=8]
CallArg[[000004].CNS_INT long (By value), 1 reg: rdx, byteAlignment=8]

Morphing args for 6.CALL:

Sorting the arguments:
Deferred argument ('rcx'):
               [000005] H----+-----                         *  CNS_INT(h) long   0x7ffd107d1a48 class
Moved to late list
Deferred argument ('rdx'):
               [000004] -----+-----                         *  CNS_INT   long   3
Moved to late list

Register placement order:    rcx rdx 
Args for [000006].CALL after fgMorphArgs:
CallArg[[000005].CNS_INT long (By value), 1 reg: rcx, byteAlignment=8, isLate, processed]
CallArg[[000004].CNS_INT long (By value), 1 reg: rdx, byteAlignment=8, isLate, processed]
OutgoingArgsStackSize is 32


fgMorphTree BB02, STMT00004 (before)
               [000013] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
               [000011] --CXG------                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
               [000010] H---------- arg0                       \--*  CNS_INT(h) long   0x7ffd107d1db0 field
Initializing arg info for 11.CALL:
Args for call [000011] CALL after AddFinalArgsAndDetermineABIInfo:
CallArg[[000010].CNS_INT long (By value), 1 reg: rcx, byteAlignment=8]

Morphing args for 11.CALL:

Sorting the arguments:
Deferred argument ('rcx'):
               [000010] H----+-----                         *  CNS_INT(h) long   0x7ffd107d1db0 field
Moved to late list

Register placement order:    rcx 
Args for [000011].CALL after fgMorphArgs:
CallArg[[000010].CNS_INT long (By value), 1 reg: rcx, byteAlignment=8, isLate, processed]
OutgoingArgsStackSize is 32

MorphCopyBlock:
PrepareDst for [000013] have found a local var V05.
block assignment to morph:
               [000013] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
               [000011] --CXG+-----                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
               [000010] H----+----- arg0 in rcx                \--*  CNS_INT(h) long   0x7ffd107d1db0 field
 src is not an L-value this requires a CopyBlock.
MorphCopyBlock (after):
               [000013] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
               [000011] --CXG+-----                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
               [000010] H----+----- arg0 in rcx                \--*  CNS_INT(h) long   0x7ffd107d1db0 field

fgMorphTree BB02, STMT00005 (before)
               [000012] --C-G------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000009] ----------- arg0                    +--*  LCL_VAR   ref    V04 tmp1         
               [000014] ----------- arg1                    \--*  LCL_VAR   struct<System.RuntimeFieldHandle, 8> V05 tmp2         
Initializing arg info for 12.CALL:
Args for call [000012] CALL after AddFinalArgsAndDetermineABIInfo:
CallArg[[000009].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8]
CallArg[[000014].LCL_VAR struct (By value), 1 reg: rdx, byteAlignment=8, isStruct]

Morphing args for 12.CALL:

Local V05 should not be enregistered because: SwizzleArg

Sorting the arguments:
Deferred argument ('rcx'):
               [000009] -----+-----                         *  LCL_VAR   ref    V04 tmp1         
Moved to late list
Deferred argument ('rdx'):
               [000014] -----+-----                         *  LCL_FLD   ref    V05 tmp2         [+0]
Moved to late list

Register placement order:    rcx rdx 
Args for [000012].CALL after fgMorphArgs:
CallArg[[000009].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8, isLate, processed]
CallArg[[000014].LCL_FLD struct (By value), 1 reg: rdx, byteAlignment=8, isLate, processed, isStruct]
OutgoingArgsStackSize is 32


fgMorphTree BB02, STMT00005 (after)
               [000012] --CXG+-----                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000009] -----+----- arg0 in rcx             +--*  LCL_VAR   ref    V04 tmp1         
               [000014] -----+----- arg1 in rdx             \--*  LCL_FLD   ref    V05 tmp2         [+0]

fgMorphTree BB02, STMT00006 (before)
               [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
               [000008] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

fgMorphTree BB02, STMT00007 (before)
               [000020] DAC-G------                         *  STORE_LCL_VAR ref    V06 tmp3         
               [000019] --C-G------                         \--*  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
               [000016] ----------- arg0                       +--*  LCL_VAR   ref    V01 loc0         
               [000017] ----------- arg1                       +--*  LCL_VAR   ref    V02 loc1         
               [000018] ----------- arg2                       \--*  CNS_INT   int    1
Initializing arg info for 19.CALL:
Args for call [000019] CALL after AddFinalArgsAndDetermineABIInfo:
CallArg[[000016].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8]
CallArg[[000017].LCL_VAR ref (By value), 1 reg: rdx, byteAlignment=8]
CallArg[[000018].CNS_INT int (By value), 1 reg: r8, byteAlignment=8]

Morphing args for 19.CALL:

Sorting the arguments:
Deferred argument ('rcx'):
               [000016] -----+-----                         *  LCL_VAR   ref    V01 loc0         
Moved to late list
Deferred argument ('rdx'):
               [000017] -----+-----                         *  LCL_VAR   ref    V02 loc1         
Moved to late list
Deferred argument ('r8'):
               [000018] -----+-----                         *  CNS_INT   int    1
Moved to late list

Register placement order:    rcx rdx r8 
Args for [000019].CALL after fgMorphArgs:
CallArg[[000016].LCL_VAR ref (By value), 1 reg: rcx, byteAlignment=8, isLate, processed]
CallArg[[000017].LCL_VAR ref (By value), 1 reg: rdx, byteAlignment=8, isLate, processed]
CallArg[[000018].CNS_INT int (By value), 1 reg: r8, byteAlignment=8, isLate, processed]
OutgoingArgsStackSize is 32


fgMorphTree BB02, STMT00008 (before)
               [000022] -----------                         *  NOP       void  

fgMorphTree BB02, STMT00009 (before)
               [000023] -----------                         *  RETURN    void  

*************** In fgMarkDemotedImplicitByRefArgs()

Expanding top-level qmark in BB01 (before)

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----+-----                         *  NOP       void  

***** BB01
STMT00010 ( ??? ... ??? )
               [000031] --C-G+-----                         *  QMARK     void  
               [000027] J---G+-N---    if                   +--*  EQ        int   
               [000025] n---G+-----                         |  +--*  IND       int   
               [000024] H----+-----                         |  |  \--*  CNS_INT(h) long   0x7ffd10611d48 global ptr
               [000026] -----+-----                         |  \--*  CNS_INT   int    0
               [000030] --C-G+?----    if                   \--*  COLON     void  
               [000028] --C-G+?---- else                       +--*  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE
               [000029] -----+?---- then                       \--*  NOP       void  

-------------------------------------------------------------------------------------------------------------------
New Basic Block BB03 [0002] created.
BB02 previous predecessor was BB01, now is BB03
Setting edge weights for BB01 -> BB03 to [0 .. 3.402823e+38]
New Basic Block BB04 [0003] created.
New Basic Block BB05 [0004] created.
Setting edge weights for BB01 -> BB04 to [0 .. 3.402823e+38]
Setting edge weights for BB04 -> BB05 to [0 .. 3.402823e+38]
Setting edge weights for BB05 -> BB03 to [0 .. 3.402823e+38]
Setting edge weights for BB04 -> BB03 to [0 .. 3.402823e+38]

removing useless STMT00010 ( ??? ... ??? )
               [000031] --C-G+-----                         *  QMARK     void  
               [000027] J---G+-N---    if                   +--*  EQ        int   
               [000025] n---G+-----                         |  +--*  IND       int   
               [000024] H----+-----                         |  |  \--*  CNS_INT(h) long   0x7ffd10611d48 global ptr
               [000026] -----+-----                         |  \--*  CNS_INT   int    0
               [000030] --C-G+?----    if                   \--*  COLON     void  
               [000028] --C-G+?---- else                       +--*  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE
               [000029] -----+?---- then                       \--*  NOP       void  
 from BB01

Expanding top-level qmark in BB01 (after)

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall 
BB04 [0003]  1       BB01                  1       [???..???)-> BB03 ( cond )                     internal 
BB05 [0004]  1       BB04                  0.50    [???..???)                                     internal 
BB03 [0002]  2       BB04,BB05             1       [???..???)                                     i internal hascall 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB04}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----+-----                         *  NOP       void  

------------ BB04 [???..???) -> BB03 (cond), preds={BB01} succs={BB05,BB03}

***** BB04
STMT00011 ( ??? ... ??? )
               [000033] ----G------                         *  JTRUE     void  
               [000027] J---G+-N---                         \--*  EQ        int   
               [000025] n---G+-----                            +--*  IND       int   
               [000024] H----+-----                            |  \--*  CNS_INT(h) long   0x7ffd10611d48 global ptr
               [000026] -----+-----                            \--*  CNS_INT   int    0

------------ BB05 [???..???), preds={BB04} succs={BB03}

***** BB05
STMT00012 ( ??? ... ??? )
               [000028] --C-G+?----                         *  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE

------------ BB03 [???..???), preds={BB04,BB05} succs={BB02}

-------------------------------------------------------------------------------------------------------------------

*************** Before renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall 
BB04 [0003]  1       BB01                  1       [???..???)-> BB03 ( cond )                     internal 
BB05 [0004]  1       BB04                  0.50    [???..???)                                     internal 
BB03 [0002]  2       BB04,BB05             1       [???..???)                                     i internal hascall 
BB02 [0001]  1       BB03                  1       [000..023)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty
Renumber BB04 to BB02
Renumber BB05 to BB03
Renumber BB03 to BB04
Renumber BB02 to BB05

*************** After renumbering the basic blocks

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

***************  Exception Handling table is empty

New BlockSet epoch 2, # of blocks (including unused BB00): 6, bitset array size: 1 (short)

*************** Finishing PHASE Morph - Global
Trees after Morph - Global

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
               [000000] -----+-----                         *  NOP       void  

------------ BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}

***** BB02
STMT00011 ( ??? ... ??? )
               [000033] ----G------                         *  JTRUE     void  
               [000027] J---G+-N---                         \--*  EQ        int   
               [000025] n---G+-----                            +--*  IND       int   
               [000024] H----+-----                            |  \--*  CNS_INT(h) long   0x7ffd10611d48 global ptr
               [000026] -----+-----                            \--*  CNS_INT   int    0

------------ BB03 [???..???), preds={BB02} succs={BB04}

***** BB03
STMT00012 ( ??? ... ??? )
               [000028] --C-G+?----                         *  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE

------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}

------------ BB05 [000..023) (return), preds={BB04} succs={}

***** BB05
STMT00001 ( 0x000[E-] ... 0x000 )
               [000001] -----+-----                         *  NO_OP     void  

***** BB05
STMT00002 ( 0x001[E-] ... 0x006 )
               [000003] DA---+-----                         *  STORE_LCL_VAR ref    V01 loc0         
               [000032] H----+-----                         \--*  CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '


***** BB05
STMT00003 ( 0x007[E-] ... 0x018 )
               [000007] DACXG+-----                         *  STORE_LCL_VAR ref    V04 tmp1         
               [000006] --CXG+-----                         \--*  CALL help ref    CORINFO_HELP_NEWARR_1_VC
               [000005] H----+----- arg0 in rcx                +--*  CNS_INT(h) long   0x7ffd107d1a48 class
               [000004] -----+----- arg1 in rdx                \--*  CNS_INT   long   3

***** BB05
STMT00004 ( 0x00D[--] ... ??? )
               [000013] DACXG+-----                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
               [000011] --CXG+-----                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
               [000010] H----+----- arg0 in rcx                \--*  CNS_INT(h) long   0x7ffd107d1db0 field

***** BB05
STMT00005 ( ??? ... ??? )
               [000012] --CXG+-----                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000009] -----+----- arg0 in rcx             +--*  LCL_VAR   ref    V04 tmp1         
               [000014] -----+----- arg1 in rdx             \--*  LCL_FLD   ref    V05 tmp2         [+0]

***** BB05
STMT00006 ( 0x018[--] ... ??? )
               [000015] DA---+-----                         *  STORE_LCL_VAR ref    V02 loc1         
               [000008] -----+-----                         \--*  LCL_VAR   ref    V04 tmp1         

***** BB05
STMT00007 ( 0x019[E-] ... 0x021 )
               [000020] DACXG+-----                         *  STORE_LCL_VAR ref    V06 tmp3         
               [000019] --CXG+-----                         \--*  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
               [000016] -----+----- arg0 in rcx                +--*  LCL_VAR   ref    V01 loc0         
               [000017] -----+----- arg1 in rdx                +--*  LCL_VAR   ref    V02 loc1         
               [000018] -----+----- arg2 in r8                 \--*  CNS_INT   int    1

***** BB05
STMT00008 ( 0x021[--] ... ??? )
               [000022] -----+-----                         *  NOP       void  

***** BB05
STMT00009 ( 0x022[E-] ... 0x022 )
               [000023] -----+-----                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
*************** In fgDebugCheckLoopTable: loop table not valid

*************** Starting PHASE GS Cookie
No GS security needed

*************** Finishing PHASE GS Cookie [no changes]

*************** Starting PHASE Compute edge weights (1, false)

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

 -- no profile data, so using default called count
 -- not optimizing or no profile data, so not computing edge weights

*************** Finishing PHASE Compute edge weights (1, false) [no changes]

*************** Starting PHASE Create EH funclets

*************** Finishing PHASE Create EH funclets [no changes]

*************** Starting PHASE Morph array ops
No multi-dimensional array references in the function

*************** Finishing PHASE Morph array ops [no changes]

*************** Starting PHASE Mark local vars

*************** In lvaMarkLocalVars()
*** lvaComputeRefCounts ***

*************** Finishing PHASE Mark local vars [no changes]

*************** Starting PHASE Find oper order
*************** In fgFindOperOrder()

*************** Finishing PHASE Find oper order
Trees after Find oper order

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
     (  0,  0) [000000] -----------                         *  NOP       void  

------------ BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}

***** BB02
STMT00011 ( ??? ... ??? )
     (  9, 16) [000033] ----G------                         *  JTRUE     void  
     (  7, 14) [000027] J---G--N---                         \--*  EQ        int   
     (  5, 12) [000025] n---G------                            +--*  IND       int   
     (  3, 10) [000024] H----------                            |  \--*  CNS_INT(h) long   0x7ffd10611d48 global ptr
     (  1,  1) [000026] -----------                            \--*  CNS_INT   int    0

------------ BB03 [???..???), preds={BB02} succs={BB04}

***** BB03
STMT00012 ( ??? ... ??? )
     ( 14,  5) [000028] --C-G-?----                         *  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE

------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}

------------ BB05 [000..023) (return), preds={BB04} succs={}

***** BB05
STMT00001 ( 0x000[E-] ... 0x000 )
     (  1,  1) [000001] -----------                         *  NO_OP     void  

***** BB05
STMT00002 ( 0x001[E-] ... 0x006 )
     (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
     (  3, 10) [000032] H----------                         \--*  CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '


***** BB05
STMT00003 ( 0x007[E-] ... 0x018 )
     ( 22, 21) [000007] DACXG------                         *  STORE_LCL_VAR ref    V04 tmp1         
     ( 18, 18) [000006] --CXG------                         \--*  CALL help ref    CORINFO_HELP_NEWARR_1_VC
     (  3, 10) [000005] H---------- arg0 in rcx                +--*  CNS_INT(h) long   0x7ffd107d1a48 class
     (  1,  1) [000004] ----------- arg1 in rdx                \--*  CNS_INT   long   3

***** BB05
STMT00004 ( 0x00D[--] ... ??? )
     ( 27, 23) [000013] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
     ( 17, 16) [000011] --CXG------                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
     (  3, 10) [000010] H---------- arg0 in rcx                \--*  CNS_INT(h) long   0x7ffd107d1db0 field

***** BB05
STMT00005 ( ??? ... ??? )
     ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
     (  3,  2) [000009] ----------- arg0 in rcx             +--*  LCL_VAR   ref    V04 tmp1         
     (  3,  4) [000014] ----------- arg1 in rdx             \--*  LCL_FLD   ref    V05 tmp2         [+0]

***** BB05
STMT00006 ( 0x018[--] ... ??? )
     (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
     (  3,  2) [000008] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

***** BB05
STMT00007 ( 0x019[E-] ... 0x021 )
     ( 25, 16) [000020] DACXG------                         *  STORE_LCL_VAR ref    V06 tmp3         
     ( 21, 13) [000019] --CXG------                         \--*  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
     (  3,  2) [000016] ----------- arg0 in rcx                +--*  LCL_VAR   ref    V01 loc0         
     (  3,  2) [000017] ----------- arg1 in rdx                +--*  LCL_VAR   ref    V02 loc1         
     (  1,  1) [000018] ----------- arg2 in r8                 \--*  CNS_INT   int    1

***** BB05
STMT00008 ( 0x021[--] ... ??? )
     (  0,  0) [000022] -----------                         *  NOP       void  

***** BB05
STMT00009 ( 0x022[E-] ... 0x022 )
     (  0,  0) [000023] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
*************** In fgDebugCheckLoopTable: loop table not valid

*************** Starting PHASE Set block order
*************** In fgSetBlockOrder()
The biggest BB has    5 tree nodes

*************** Finishing PHASE Set block order
Trees after Set block order

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}

***** BB01
STMT00000 ( ??? ... ??? )
N001 (  0,  0) [000000] -----------                         *  NOP       void  

------------ BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}

***** BB02
STMT00011 ( ??? ... ??? )
N005 (  9, 16) [000033] ----G------                         *  JTRUE     void  
N004 (  7, 14) [000027] J---G--N---                         \--*  EQ        int   
N002 (  5, 12) [000025] n---G------                            +--*  IND       int   
N001 (  3, 10) [000024] H----------                            |  \--*  CNS_INT(h) long   0x7ffd10611d48 global ptr
N003 (  1,  1) [000026] -----------                            \--*  CNS_INT   int    0

------------ BB03 [???..???), preds={BB02} succs={BB04}

***** BB03
STMT00012 ( ??? ... ??? )
N001 ( 14,  5) [000028] --C-G-?----                         *  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE

------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}

------------ BB05 [000..023) (return), preds={BB04} succs={}

***** BB05
STMT00001 ( 0x000[E-] ... 0x000 )
N001 (  1,  1) [000001] -----------                         *  NO_OP     void  

***** BB05
STMT00002 ( 0x001[E-] ... 0x006 )
N002 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
N001 (  3, 10) [000032] H----------                         \--*  CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '


***** BB05
STMT00003 ( 0x007[E-] ... 0x018 )
N004 ( 22, 21) [000007] DACXG------                         *  STORE_LCL_VAR ref    V04 tmp1         
N003 ( 18, 18) [000006] --CXG------                         \--*  CALL help ref    CORINFO_HELP_NEWARR_1_VC
N001 (  3, 10) [000005] H---------- arg0 in rcx                +--*  CNS_INT(h) long   0x7ffd107d1a48 class
N002 (  1,  1) [000004] ----------- arg1 in rdx                \--*  CNS_INT   long   3

***** BB05
STMT00004 ( 0x00D[--] ... ??? )
N003 ( 27, 23) [000013] DACXG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
N002 ( 17, 16) [000011] --CXG------                         \--*  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
N001 (  3, 10) [000010] H---------- arg0 in rcx                \--*  CNS_INT(h) long   0x7ffd107d1db0 field

***** BB05
STMT00005 ( ??? ... ??? )
N003 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
N001 (  3,  2) [000009] ----------- arg0 in rcx             +--*  LCL_VAR   ref    V04 tmp1         
N002 (  3,  4) [000014] ----------- arg1 in rdx             \--*  LCL_FLD   ref    V05 tmp2         [+0]

***** BB05
STMT00006 ( 0x018[--] ... ??? )
N002 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
N001 (  3,  2) [000008] -----------                         \--*  LCL_VAR   ref    V04 tmp1         

***** BB05
STMT00007 ( 0x019[E-] ... 0x021 )
N005 ( 25, 16) [000020] DACXG------                         *  STORE_LCL_VAR ref    V06 tmp3         
N004 ( 21, 13) [000019] --CXG------                         \--*  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
N001 (  3,  2) [000016] ----------- arg0 in rcx                +--*  LCL_VAR   ref    V01 loc0         
N002 (  3,  2) [000017] ----------- arg1 in rdx                +--*  LCL_VAR   ref    V02 loc1         
N003 (  1,  1) [000018] ----------- arg2 in r8                 \--*  CNS_INT   int    1

***** BB05
STMT00008 ( 0x021[--] ... ??? )
N001 (  0,  0) [000022] -----------                         *  NOP       void  

***** BB05
STMT00009 ( 0x022[E-] ... 0x022 )
N001 (  0,  0) [000023] -----------                         *  RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
*************** In fgDebugCheckLoopTable: loop table not valid

*************** Starting PHASE Stress gtSplitTree

*************** Finishing PHASE Stress gtSplitTree [no changes]

*************** Starting PHASE Expand runtime lookups

*************** Finishing PHASE Expand runtime lookups [no changes]

*************** Starting PHASE Expand static init
Nothing to expand.

*************** Finishing PHASE Expand static init [no changes]

*************** Starting PHASE Expand TLS access
Nothing to expand.

*************** Finishing PHASE Expand TLS access [no changes]

*************** Starting PHASE Insert GC Polls

*************** Finishing PHASE Insert GC Polls [no changes]

*************** Starting PHASE Determine first cold block
No procedure splitting will be done for this method

*************** Finishing PHASE Determine first cold block [no changes]

*************** Starting PHASE Rationalize IR

*************** Finishing PHASE Rationalize IR
Trees after Rationalize IR

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall LIR 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal LIR 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal LIR 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall LIR 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}
N001 (  3, 10) [000024] H----------                   t24 =    CNS_INT(h) long   0x7ffd10611d48 global ptr
                                                            /--*  t24    long   
N002 (  5, 12) [000025] n---G------                   t25 = *  IND       int   
N003 (  1,  1) [000026] -----------                   t26 =    CNS_INT   int    0
                                                            /--*  t25    int    
                                                            +--*  t26    int    
N004 (  7, 14) [000027] J---G--N---                   t27 = *  EQ        int   
                                                            /--*  t27    int    
N005 (  9, 16) [000033] ----G------                         *  JTRUE     void  

------------ BB03 [???..???), preds={BB02} succs={BB04}
N001 ( 14,  5) [000028] --C-G-?----                            CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE

------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}

------------ BB05 [000..023) (return), preds={BB04} succs={}
               [000034] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 (  1,  1) [000001] -----------                            NO_OP     void  
               [000035] -----------                            IL_OFFSET void   INLRT @ 0x001[E-]
N001 (  3, 10) [000032] H----------                   t32 =    CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

                                                            /--*  t32    ref    
N002 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
               [000036] -----------                            IL_OFFSET void   INLRT @ 0x007[E-]
N001 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class
N002 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3
                                                            /--*  t5     long   arg0 in rcx
                                                            +--*  t4     long   arg1 in rdx
N003 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC
                                                            /--*  t6     ref    
N004 ( 22, 21) [000007] DA-XG------                         *  STORE_LCL_VAR ref    V04 tmp1         
               [000037] -----------                            IL_OFFSET void   INLRT @ 0x00D[--]
N001 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field
                                                            /--*  t10    long   arg0 in rcx
N002 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
                                                            /--*  t11    struct 
N003 ( 27, 23) [000013] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
N001 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   ref    V04 tmp1         
N002 (  3,  4) [000014] -----------                   t14 =    LCL_FLD   ref    V05 tmp2         [+0]
                                                            /--*  t9     ref    arg0 in rcx
                                                            +--*  t14    ref    arg1 in rdx
N003 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000038] -----------                            IL_OFFSET void   INLRT @ 0x018[--]
N001 (  3,  2) [000008] -----------                    t8 =    LCL_VAR   ref    V04 tmp1         
                                                            /--*  t8     ref    
N002 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
               [000039] -----------                            IL_OFFSET void   INLRT @ 0x019[E-]
N001 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0         
N002 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1         
N003 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1
                                                            /--*  t16    ref    arg0 in rcx
                                                            +--*  t17    ref    arg1 in rdx
                                                            +--*  t18    int    arg2 in r8
N004 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
                                                            /--*  t19    ref    
N005 ( 25, 16) [000020] DA-XG------                         *  STORE_LCL_VAR ref    V06 tmp3         
               [000040] -----------                            IL_OFFSET void   INLRT @ 0x021[--]
N001 (  0,  0) [000022] -----------                            NOP       void  
               [000041] -----------                            IL_OFFSET void   INLRT @ 0x022[E-]
N001 (  0,  0) [000023] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
*************** In fgDebugCheckLoopTable: loop table not valid

*************** Starting PHASE Do 'simple' lowering

*************** Finishing PHASE Do 'simple' lowering [no changes]

*************** Starting PHASE Lowering nodeinfo
compEnregLocals() is false, setting doNotEnreg flag for all locals.
Local V00 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V01 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V02 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V03 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V04 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V05 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set

Local V06 should not be enregistered because: opts.compFlags & CLFLG_REGVAR is not set
Lowering JTRUE:
N001 (  3, 10) [000024] Hc---------                   t24 =    CNS_INT(h) long   0x7ffd10611d48 global ptr
                                                            /--*  t24    long   
N002 (  5, 12) [000025] nc--G------                   t25 = *  IND       int   
N003 (  1,  1) [000026] -c---------                   t26 =    CNS_INT   int    0
                                                            /--*  t25    int    
                                                            +--*  t26    int    
N004 (  7, 14) [000027] J---G--N---                   t27 = *  EQ        int   
                                                            /--*  t27    int    
N005 (  9, 16) [000033] ----G------                         *  JTRUE     void  

Lowering condition:
N001 (  3, 10) [000024] Hc---------                   t24 =    CNS_INT(h) long   0x7ffd10611d48 global ptr
                                                            /--*  t24    long   
N002 (  5, 12) [000025] nc--G------                   t25 = *  IND       int   
N003 (  1,  1) [000026] -c---------                   t26 =    CNS_INT   int    0
                                                            /--*  t25    int    
                                                            +--*  t26    int    
N004 (  7, 14) [000027] J---G--N---                   t27 = *  EQ        int   

Lowering JTRUE Result:
N001 (  3, 10) [000024] Hc---------                   t24 =    CNS_INT(h) long   0x7ffd10611d48 global ptr
                                                            /--*  t24    long   
N002 (  5, 12) [000025] nc--G------                   t25 = *  IND       int   
N003 (  1,  1) [000026] -c---------                   t26 =    CNS_INT   int    0
                                                            /--*  t25    int    
                                                            +--*  t26    int    
N004 (  7, 14) [000027] ----G--N---                         *  CMP       void  
N005 (  9, 16) [000033] ----G------                            JCC       void   cond=UEQ

lowering call (before):
N001 ( 14,  5) [000028] --C-G-?----                            CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE

args:
======

late:
======
Bumping outgoing arg space size from 0 to 32 for [000028]
lowering call (after):
N001 ( 14,  5) [000028] --C-G-?----                            CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE

lowering store lcl var/field (before):
N001 (  3, 10) [000032] H----------                   t32 =    CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

                                                            /--*  t32    ref    
N002 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         

lowering store lcl var/field (after):
N001 (  3, 10) [000032] H----------                   t32 =    CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

                                                            /--*  t32    ref    
N002 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         

lowering call (before):
N001 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class
N002 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3
                                                            /--*  t5     long   arg0 in rcx
                                                            +--*  t4     long   arg1 in rdx
N003 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC

args:
======

late:
======
lowering arg : N001 (  3, 10) [000005] H----------                         *  CNS_INT(h) long   0x7ffd107d1a48 class
new node is :                [000042] -----------                         *  PUTARG_REG long   REG rcx

lowering arg : N002 (  1,  1) [000004] -----------                         *  CNS_INT   long   3
new node is :                [000043] -----------                         *  PUTARG_REG long   REG rdx

lowering call (after):
N001 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class
                                                            /--*  t5     long   
               [000042] -----------                   t42 = *  PUTARG_REG long   REG rcx
N002 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3
                                                            /--*  t4     long   
               [000043] -----------                   t43 = *  PUTARG_REG long   REG rdx
                                                            /--*  t42    long   arg0 in rcx
                                                            +--*  t43    long   arg1 in rdx
N003 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC

lowering store lcl var/field (before):
N001 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class
                                                            /--*  t5     long   
               [000042] -----------                   t42 = *  PUTARG_REG long   REG rcx
N002 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3
                                                            /--*  t4     long   
               [000043] -----------                   t43 = *  PUTARG_REG long   REG rdx
                                                            /--*  t42    long   arg0 in rcx
                                                            +--*  t43    long   arg1 in rdx
N003 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC
                                                            /--*  t6     ref    
N004 ( 22, 21) [000007] DA-XG------                         *  STORE_LCL_VAR ref    V04 tmp1         

lowering store lcl var/field (after):
N001 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class
                                                            /--*  t5     long   
               [000042] -----------                   t42 = *  PUTARG_REG long   REG rcx
N002 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3
                                                            /--*  t4     long   
               [000043] -----------                   t43 = *  PUTARG_REG long   REG rdx
                                                            /--*  t42    long   arg0 in rcx
                                                            +--*  t43    long   arg1 in rdx
N003 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC
                                                            /--*  t6     ref    
N004 ( 22, 21) [000007] DA-XG------                         *  STORE_LCL_VAR ref    V04 tmp1         

lowering call (before):
N001 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field
                                                            /--*  t10    long   arg0 in rcx
N002 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help struct CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD

args:
======

late:
======
lowering arg : N001 (  3, 10) [000010] H----------                         *  CNS_INT(h) long   0x7ffd107d1db0 field
new node is :                [000044] -----------                         *  PUTARG_REG long   REG rcx

lowering call (after):
N001 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field
                                                            /--*  t10    long   
               [000044] -----------                   t44 = *  PUTARG_REG long   REG rcx
                                                            /--*  t44    long   arg0 in rcx
N002 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help ref    CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD

lowering store lcl var/field (before):
N001 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field
                                                            /--*  t10    long   
               [000044] -----------                   t44 = *  PUTARG_REG long   REG rcx
                                                            /--*  t44    long   arg0 in rcx
N002 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help ref    CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
                                                            /--*  t11    ref    
N003 ( 27, 23) [000013] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         

lowering store lcl var/field (after):
N001 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field
                                                            /--*  t10    long   
               [000044] -----------                   t44 = *  PUTARG_REG long   REG rcx
                                                            /--*  t44    long   arg0 in rcx
N002 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help ref    CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
                                                            /--*  t11    ref    
N003 ( 27, 23) [000013] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         

lowering call (before):
N001 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   ref    V04 tmp1         
N002 (  3,  4) [000014] -----------                   t14 =    LCL_FLD   ref    V05 tmp2         [+0]
                                                            /--*  t9     ref    arg0 in rcx
                                                            +--*  t14    ref    arg1 in rdx
N003 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)

args:
======

late:
======
lowering arg : N001 (  3,  2) [000009] -----------                         *  LCL_VAR   ref    V04 tmp1         
new node is :                [000045] -----------                         *  PUTARG_REG ref    REG rcx

lowering arg : N002 (  3,  4) [000014] -----------                         *  LCL_FLD   ref    V05 tmp2         [+0]
new node is :                [000046] -----------                         *  PUTARG_REG ref    REG rdx

lowering call (after):
N001 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   ref    V04 tmp1         
                                                            /--*  t9     ref    
               [000045] -----------                   t45 = *  PUTARG_REG ref    REG rcx
N002 (  3,  4) [000014] -----------                   t14 =    LCL_FLD   ref    V05 tmp2         [+0]
                                                            /--*  t14    ref    
               [000046] -----------                   t46 = *  PUTARG_REG ref    REG rdx
                                                            /--*  t45    ref    arg0 in rcx
                                                            +--*  t46    ref    arg1 in rdx
N003 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)

lowering store lcl var/field (before):
N001 (  3,  2) [000008] -----------                    t8 =    LCL_VAR   ref    V04 tmp1         
                                                            /--*  t8     ref    
N002 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         

lowering store lcl var/field (after):
N001 (  3,  2) [000008] -----------                    t8 =    LCL_VAR   ref    V04 tmp1         
                                                            /--*  t8     ref    
N002 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         

lowering call (before):
N001 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0         
N002 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1         
N003 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1
                                                            /--*  t16    ref    arg0 in rcx
                                                            +--*  t17    ref    arg1 in rdx
                                                            +--*  t18    int    arg2 in r8
N004 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]

args:
======

late:
======
lowering arg : N001 (  3,  2) [000016] -----------                         *  LCL_VAR   ref    V01 loc0         
new node is :                [000047] -----------                         *  PUTARG_REG ref    REG rcx

lowering arg : N002 (  3,  2) [000017] -----------                         *  LCL_VAR   ref    V02 loc1         
new node is :                [000048] -----------                         *  PUTARG_REG ref    REG rdx

lowering arg : N003 (  1,  1) [000018] -----------                         *  CNS_INT   int    1
new node is :                [000049] -----------                         *  PUTARG_REG int    REG r8

results of lowering call:
N001 (  3, 10) [000050] H----------                   t50 =    CNS_INT(h) long   0x7ffd10624cd8 ftn
                                                            /--*  t50    long   
N002 (  5, 12) [000051] n---G------                   t51 = *  IND       long  
lowering call (after):
N001 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0         
                                                            /--*  t16    ref    
               [000047] -----------                   t47 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1         
                                                            /--*  t17    ref    
               [000048] -----------                   t48 = *  PUTARG_REG ref    REG rdx
N003 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1
                                                            /--*  t18    int    
               [000049] -----------                   t49 = *  PUTARG_REG int    REG r8
N001 (  3, 10) [000050] Hc---------                   t50 =    CNS_INT(h) long   0x7ffd10624cd8 ftn
                                                            /--*  t50    long   
N002 (  5, 12) [000051] nc--G------                   t51 = *  IND       long   REG NA
                                                            /--*  t47    ref    arg0 in rcx
                                                            +--*  t48    ref    arg1 in rdx
                                                            +--*  t49    int    arg2 in r8
                                                            +--*  t51    long   control expr
N004 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]

lowering store lcl var/field (before):
N001 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0         
                                                            /--*  t16    ref    
               [000047] -----------                   t47 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1         
                                                            /--*  t17    ref    
               [000048] -----------                   t48 = *  PUTARG_REG ref    REG rdx
N003 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1
                                                            /--*  t18    int    
               [000049] -----------                   t49 = *  PUTARG_REG int    REG r8
N001 (  3, 10) [000050] Hc---------                   t50 =    CNS_INT(h) long   0x7ffd10624cd8 ftn
                                                            /--*  t50    long   
N002 (  5, 12) [000051] nc--G------                   t51 = *  IND       long   REG NA
                                                            /--*  t47    ref    arg0 in rcx
                                                            +--*  t48    ref    arg1 in rdx
                                                            +--*  t49    int    arg2 in r8
                                                            +--*  t51    long   control expr
N004 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
                                                            /--*  t19    ref    
N005 ( 25, 16) [000020] DA-XG------                         *  STORE_LCL_VAR ref    V06 tmp3         

lowering store lcl var/field (after):
N001 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0         
                                                            /--*  t16    ref    
               [000047] -----------                   t47 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1         
                                                            /--*  t17    ref    
               [000048] -----------                   t48 = *  PUTARG_REG ref    REG rdx
N003 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1
                                                            /--*  t18    int    
               [000049] -----------                   t49 = *  PUTARG_REG int    REG r8
N001 (  3, 10) [000050] Hc---------                   t50 =    CNS_INT(h) long   0x7ffd10624cd8 ftn
                                                            /--*  t50    long   
N002 (  5, 12) [000051] nc--G------                   t51 = *  IND       long   REG NA
                                                            /--*  t47    ref    arg0 in rcx
                                                            +--*  t48    ref    arg1 in rdx
                                                            +--*  t49    int    arg2 in r8
                                                            +--*  t51    long   control expr
N004 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
                                                            /--*  t19    ref    
N005 ( 25, 16) [000020] DA-XG------                         *  STORE_LCL_VAR ref    V06 tmp3         

lowering GT_RETURN
N001 (  0,  0) [000023] -----------                         *  RETURN    void  
============Lower has completed modifying nodes.

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall LIR 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal LIR 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal LIR 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall LIR 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}
N001 (  3, 10) [000024] Hc---------                   t24 =    CNS_INT(h) long   0x7ffd10611d48 global ptr
                                                            /--*  t24    long   
N002 (  5, 12) [000025] nc--G------                   t25 = *  IND       int   
N003 (  1,  1) [000026] -c---------                   t26 =    CNS_INT   int    0
                                                            /--*  t25    int    
                                                            +--*  t26    int    
N004 (  7, 14) [000027] ----G--N---                         *  CMP       void  
N005 (  9, 16) [000033] ----G------                            JCC       void   cond=UEQ

------------ BB03 [???..???), preds={BB02} succs={BB04}
N001 ( 14,  5) [000028] --C-G-?----                            CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE

------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}

------------ BB05 [000..023) (return), preds={BB04} succs={}
               [000034] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 (  1,  1) [000001] -----------                            NO_OP     void  
               [000035] -----------                            IL_OFFSET void   INLRT @ 0x001[E-]
N001 (  3, 10) [000032] H----------                   t32 =    CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

                                                            /--*  t32    ref    
N002 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
               [000036] -----------                            IL_OFFSET void   INLRT @ 0x007[E-]
N001 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class
                                                            /--*  t5     long   
               [000042] -----------                   t42 = *  PUTARG_REG long   REG rcx
N002 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3
                                                            /--*  t4     long   
               [000043] -----------                   t43 = *  PUTARG_REG long   REG rdx
                                                            /--*  t42    long   arg0 in rcx
                                                            +--*  t43    long   arg1 in rdx
N003 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC
                                                            /--*  t6     ref    
N004 ( 22, 21) [000007] DA-XG------                         *  STORE_LCL_VAR ref    V04 tmp1         
               [000037] -----------                            IL_OFFSET void   INLRT @ 0x00D[--]
N001 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field
                                                            /--*  t10    long   
               [000044] -----------                   t44 = *  PUTARG_REG long   REG rcx
                                                            /--*  t44    long   arg0 in rcx
N002 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help ref    CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
                                                            /--*  t11    ref    
N003 ( 27, 23) [000013] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
N001 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   ref    V04 tmp1         
                                                            /--*  t9     ref    
               [000045] -----------                   t45 = *  PUTARG_REG ref    REG rcx
N002 (  3,  4) [000014] -----------                   t14 =    LCL_FLD   ref    V05 tmp2         [+0]
                                                            /--*  t14    ref    
               [000046] -----------                   t46 = *  PUTARG_REG ref    REG rdx
                                                            /--*  t45    ref    arg0 in rcx
                                                            +--*  t46    ref    arg1 in rdx
N003 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000038] -----------                            IL_OFFSET void   INLRT @ 0x018[--]
N001 (  3,  2) [000008] -----------                    t8 =    LCL_VAR   ref    V04 tmp1         
                                                            /--*  t8     ref    
N002 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
               [000039] -----------                            IL_OFFSET void   INLRT @ 0x019[E-]
N001 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0         
                                                            /--*  t16    ref    
               [000047] -----------                   t47 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1         
                                                            /--*  t17    ref    
               [000048] -----------                   t48 = *  PUTARG_REG ref    REG rdx
N003 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1
                                                            /--*  t18    int    
               [000049] -----------                   t49 = *  PUTARG_REG int    REG r8
N001 (  3, 10) [000050] Hc---------                   t50 =    CNS_INT(h) long   0x7ffd10624cd8 ftn
                                                            /--*  t50    long   
N002 (  5, 12) [000051] nc--G------                   t51 = *  IND       long   REG NA
                                                            /--*  t47    ref    arg0 in rcx
                                                            +--*  t48    ref    arg1 in rdx
                                                            +--*  t49    int    arg2 in r8
                                                            +--*  t51    long   control expr
N004 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
                                                            /--*  t19    ref    
N005 ( 25, 16) [000020] DA-XG------                         *  STORE_LCL_VAR ref    V06 tmp3         
               [000040] -----------                            IL_OFFSET void   INLRT @ 0x021[--]
N001 (  0,  0) [000022] -----------                            NOP       void  
               [000041] -----------                            IL_OFFSET void   INLRT @ 0x022[E-]
N001 (  0,  0) [000023] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------

*** lvaComputeRefCounts ***
*************** In fgLocalVarLiveness()
; Initial local variable assignments
;
;  V00 arg0              ref  do-not-enreg[] class-hnd <System.String[]>
;  V01 loc0              ref  do-not-enreg[] class-hnd exact <System.String>
;  V02 loc1              ref  do-not-enreg[] class-hnd exact <ushort[]>
;  V03 OutArgs        struct <32> do-not-enreg[XS] addr-exposed "OutgoingArgSpace"
;  V04 tmp1              ref  do-not-enreg[] class-hnd exact "impSpillStackEnsure" <ushort[]>
;  V05 tmp2           struct <System.RuntimeFieldHandle, 8> do-not-enreg[S] "spilled call-like call argument" <System.RuntimeFieldHandle>
;  V06 tmp3              ref  do-not-enreg[] class-hnd exact "impSpillStackEnsure" <System.String[]>
In fgLocalVarLivenessInit
*************** In fgPerBlockLocalVarLiveness()
*************** In fgInterBlockLocalVarLiveness()
*************** In fgExtendDbgLifetimes()

Marking vars alive over their entire scope :

Local variable scopes = 3
    	VarNum 	LVNum 	      Name 	Beg 	End
Sorted by enter scope:
 0: 	00h 	00h 	  V00 arg0 	000h   	023h <-- next enter scope
 1: 	01h 	01h 	  V01 loc0 	000h   	023h
 2: 	02h 	02h 	  V02 loc1 	000h   	023h
Sorted by exit scope:
 0: 	00h 	00h 	  V00 arg0 	000h   	023h <-- next exit scope
 1: 	01h 	01h 	  V01 loc0 	000h   	023h
 2: 	02h 	02h 	  V02 loc1 	000h   	023h
Scope info: block BB01 marking in scope: {}
Scope info: block BB02 marking in scope: {}
Scope info: block BB03 marking in scope: {}
Scope info: block BB04 marking in scope: {}
Scope info: block BB05 marking in scope: {}

Debug scopes:
BB01: {}
BB02: {}
BB03: {}
BB04: {}
BB05: {}
Scope info: block BB01 UNmarking in scope: {}

BB liveness after fgExtendDbgLifetimes():

BB01 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

BB02 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

BB03 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

BB04 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

BB05 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap



*************** In fgRemoveDeadBlocks()
Removing unreachable blocks for fgRemoveDeadBlocks iteration #1
*************** In fgDebugCheckBBlist

*** lvaComputeRefCounts ***

*************** Finishing PHASE Lowering nodeinfo
Trees after Lowering nodeinfo

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall LIR 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal LIR 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal LIR 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall LIR 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N001 (  0,  0) [000000] -----------                            NOP       void  

------------ BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}
N001 (  3, 10) [000024] Hc---------                   t24 =    CNS_INT(h) long   0x7ffd10611d48 global ptr
                                                            /--*  t24    long   
N002 (  5, 12) [000025] nc--G------                   t25 = *  IND       int   
N003 (  1,  1) [000026] -c---------                   t26 =    CNS_INT   int    0
                                                            /--*  t25    int    
                                                            +--*  t26    int    
N004 (  7, 14) [000027] ----G--N---                         *  CMP       void  
N005 (  9, 16) [000033] ----G------                            JCC       void   cond=UEQ

------------ BB03 [???..???), preds={BB02} succs={BB04}
N001 ( 14,  5) [000028] --C-G-?----                            CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE

------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}

------------ BB05 [000..023) (return), preds={BB04} succs={}
               [000034] -----------                            IL_OFFSET void   INLRT @ 0x000[E-]
N001 (  1,  1) [000001] -----------                            NO_OP     void  
               [000035] -----------                            IL_OFFSET void   INLRT @ 0x001[E-]
N001 (  3, 10) [000032] H----------                   t32 =    CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

                                                            /--*  t32    ref    
N002 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0         
               [000036] -----------                            IL_OFFSET void   INLRT @ 0x007[E-]
N001 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class
                                                            /--*  t5     long   
               [000042] -----------                   t42 = *  PUTARG_REG long   REG rcx
N002 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3
                                                            /--*  t4     long   
               [000043] -----------                   t43 = *  PUTARG_REG long   REG rdx
                                                            /--*  t42    long   arg0 in rcx
                                                            +--*  t43    long   arg1 in rdx
N003 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC
                                                            /--*  t6     ref    
N004 ( 22, 21) [000007] DA-XG------                         *  STORE_LCL_VAR ref    V04 tmp1         
               [000037] -----------                            IL_OFFSET void   INLRT @ 0x00D[--]
N001 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field
                                                            /--*  t10    long   
               [000044] -----------                   t44 = *  PUTARG_REG long   REG rcx
                                                            /--*  t44    long   arg0 in rcx
N002 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help ref    CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
                                                            /--*  t11    ref    
N003 ( 27, 23) [000013] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2         
N001 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   ref    V04 tmp1         
                                                            /--*  t9     ref    
               [000045] -----------                   t45 = *  PUTARG_REG ref    REG rcx
N002 (  3,  4) [000014] -----------                   t14 =    LCL_FLD   ref    V05 tmp2         [+0]
                                                            /--*  t14    ref    
               [000046] -----------                   t46 = *  PUTARG_REG ref    REG rdx
                                                            /--*  t45    ref    arg0 in rcx
                                                            +--*  t46    ref    arg1 in rdx
N003 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
               [000038] -----------                            IL_OFFSET void   INLRT @ 0x018[--]
N001 (  3,  2) [000008] -----------                    t8 =    LCL_VAR   ref    V04 tmp1         
                                                            /--*  t8     ref    
N002 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1         
               [000039] -----------                            IL_OFFSET void   INLRT @ 0x019[E-]
N001 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0         
                                                            /--*  t16    ref    
               [000047] -----------                   t47 = *  PUTARG_REG ref    REG rcx
N002 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1         
                                                            /--*  t17    ref    
               [000048] -----------                   t48 = *  PUTARG_REG ref    REG rdx
N003 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1
                                                            /--*  t18    int    
               [000049] -----------                   t49 = *  PUTARG_REG int    REG r8
N001 (  3, 10) [000050] Hc---------                   t50 =    CNS_INT(h) long   0x7ffd10624cd8 ftn
                                                            /--*  t50    long   
N002 (  5, 12) [000051] nc--G------                   t51 = *  IND       long   REG NA
                                                            /--*  t47    ref    arg0 in rcx
                                                            +--*  t48    ref    arg1 in rdx
                                                            +--*  t49    int    arg2 in r8
                                                            +--*  t51    long   control expr
N004 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]
                                                            /--*  t19    ref    
N005 ( 25, 16) [000020] DA-XG------                         *  STORE_LCL_VAR ref    V06 tmp3         
               [000040] -----------                            IL_OFFSET void   INLRT @ 0x021[--]
N001 (  0,  0) [000022] -----------                            NOP       void  
               [000041] -----------                            IL_OFFSET void   INLRT @ 0x022[E-]
N001 (  0,  0) [000023] -----------                            RETURN    void  

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
*************** In fgDebugCheckLoopTable: loop table not valid

*************** Starting PHASE Calculate stack level slots

*************** Finishing PHASE Calculate stack level slots [no changes]

*************** Starting PHASE Linear scan register alloc
Clearing modified regs.

buildIntervals ========

-----------------
LIVENESS:
-----------------
BB01
use: {}
def: {}
 in: {}
out: {}
BB02
use: {}
def: {}
 in: {}
out: {}
BB03
use: {}
def: {}
 in: {}
out: {}
BB04
use: {}
def: {}
 in: {}
out: {}
BB05
use: {}
def: {}
 in: {}
out: {}

FP callee save candidate vars: None

floatVarCount = 0; hasLoops = false, singleExit = true
TUPLE STYLE DUMP BEFORE LSRA
Start LSRA Block Sequence: 
Current block: BB01
	Succ block: BB02, Criteria: weight, Worklist: [BB02 ]
Current block: BB02
	Succ block: BB03, Criteria: weight, Worklist: [BB03 ]
	Succ block: BB04, Criteria: weight, Worklist: [BB03 BB04 ]
Current block: BB03
Current block: BB04
	Succ block: BB05, Criteria: bbNum, Worklist: [BB05 ]
Current block: BB05
Final LSRA Block Sequence:
BB01 (  1   )
BB02 (  1   ) critical-out
BB03 (  0.50)
BB04 (  1   ) critical-in
BB05 (  1   )

BB01 [???..???), preds={} succs={BB02}
=====
  N001.                    NOP      

BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}
=====
  N001.                    CNS_INT(h) 0x7ffd10611d48 global ptr
  N002.                    IND      
  N003.                    CNS_INT   0
  N004.                    CMP      
  N005.                    JCC       cond=UEQ

BB03 [???..???), preds={BB02} succs={BB04}
=====
  N001.                    CALL help

BB04 [???..???), preds={BB02,BB03} succs={BB05}
=====

BB05 [000..023) (return), preds={BB04} succs={}
=====
  N000.                    IL_OFFSET INLRT @ 0x000[E-]
  N001.                    NO_OP    
  N000.                    IL_OFFSET INLRT @ 0x001[E-]
  N001. t32             =  CNS_INT(h)  'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

  N002.                    V01 MEM; t32
  N000.                    IL_OFFSET INLRT @ 0x007[E-]
  N001. t5              =  CNS_INT(h) 0x7ffd107d1a48 class
  N000. t42             =  PUTARG_REG; t5
  N002. t4              =  CNS_INT   3
  N000. t43             =  PUTARG_REG; t4
  N003. t6              =  CALL help; t42,t43
  N004.                    V04 MEM; t6
  N000.                    IL_OFFSET INLRT @ 0x00D[--]
  N001. t10             =  CNS_INT(h) 0x7ffd107d1db0 field
  N000. t44             =  PUTARG_REG; t10
  N002. t11             =  CALL help; t44
  N003.                    V05 MEM; t11
  N001. t9              =  V04 MEM
  N000. t45             =  PUTARG_REG; t9
  N002. t14             =  V05 MEM
  N000. t46             =  PUTARG_REG; t14
  N003.                    CALL     ; t45,t46
  N000.                    IL_OFFSET INLRT @ 0x018[--]
  N001. t8              =  V04 MEM
  N002.                    V02 MEM; t8
  N000.                    IL_OFFSET INLRT @ 0x019[E-]
  N001. t16             =  V01 MEM
  N000. t47             =  PUTARG_REG; t16
  N002. t17             =  V02 MEM
  N000. t48             =  PUTARG_REG; t17
  N003. t18             =  CNS_INT   1
  N000. t49             =  PUTARG_REG; t18
  N001.                    CNS_INT(h) 0x7ffd10624cd8 ftn
  N002.                    IND      
  N004. t19             =  CALL     ; t47,t48,t49
  N005.                    V06 MEM; t19
  N000.                    IL_OFFSET INLRT @ 0x021[--]
  N001.                    NOP      
  N000.                    IL_OFFSET INLRT @ 0x022[E-]
  N001.                    RETURN   




buildIntervals second part ========
Int arg V00 in reg rcx

NEW BLOCK BB01
<RefPosition #0   @0   RefTypeBB BB01 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N002 (  0,  0) [000000] -----------                         *  NOP       void   REG NA


NEW BLOCK BB02


Setting BB01 as the predecessor for determining incoming variable registers of BB02
<RefPosition #1   @4   RefTypeBB BB02 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N006 (  3, 10) [000024] Hc---------                         *  CNS_INT(h) long   0x7ffd10611d48 global ptr REG NA
Contained
DefList: {  }
N008 (  5, 12) [000025] nc--G------                         *  IND       int    REG NA
Contained
DefList: {  }
N010 (  1,  1) [000026] -c---------                         *  CNS_INT   int    0 REG NA
Contained
DefList: {  }
N012 (  7, 14) [000027] ----G--N---                         *  CMP       void   REG NA

DefList: {  }
N014 (  9, 16) [000033] ----G------                         *  JCC       void   cond=UEQ REG NA


NEW BLOCK BB03


Setting BB02 as the predecessor for determining incoming variable registers of BB03
<RefPosition #2   @16  RefTypeBB BB03 regmask=[] minReg=1 wt=50.00>

DefList: {  }
N018 ( 14,  5) [000028] --C-G-?----                         *  CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE REG NA
<RefPosition #3   @19  RefTypeKill <Reg:rax> BB03 regmask=[rax] minReg=1 wt=50.00>
<RefPosition #4   @19  RefTypeKill <Reg:rcx> BB03 regmask=[rcx] minReg=1 wt=50.00>
<RefPosition #5   @19  RefTypeKill <Reg:rdx> BB03 regmask=[rdx] minReg=1 wt=50.00>
<RefPosition #6   @19  RefTypeKill <Reg:r8 > BB03 regmask=[r8] minReg=1 wt=50.00>
<RefPosition #7   @19  RefTypeKill <Reg:r9 > BB03 regmask=[r9] minReg=1 wt=50.00>
<RefPosition #8   @19  RefTypeKill <Reg:r10> BB03 regmask=[r10] minReg=1 wt=50.00>
<RefPosition #9   @19  RefTypeKill <Reg:r11> BB03 regmask=[r11] minReg=1 wt=50.00>


NEW BLOCK BB04


Setting BB02 as the predecessor for determining incoming variable registers of BB04
<RefPosition #10  @20  RefTypeBB BB04 regmask=[] minReg=1 wt=100.00>


NEW BLOCK BB05


Setting BB04 as the predecessor for determining incoming variable registers of BB05
<RefPosition #11  @22  RefTypeBB BB05 regmask=[] minReg=1 wt=100.00>

DefList: {  }
N024 (???,???) [000034] -----------                         *  IL_OFFSET void   INLRT @ 0x000[E-] REG NA

DefList: {  }
N026 (  1,  1) [000001] -----------                         *  NO_OP     void   REG NA

DefList: {  }
N028 (???,???) [000035] -----------                         *  IL_OFFSET void   INLRT @ 0x001[E-] REG NA

DefList: {  }
N030 (  3, 10) [000032] H----------                         *  CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '
 REG NA
Interval  0: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #12  @31  RefTypeDef <Ivl:0> CNS_INT BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N030.t32. CNS_INT }
N032 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0          NA REG NA
<RefPosition #13  @32  RefTypeUse <Ivl:0> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>

DefList: {  }
N034 (???,???) [000036] -----------                         *  IL_OFFSET void   INLRT @ 0x007[E-] REG NA

DefList: {  }
N036 (  3, 10) [000005] H----------                         *  CNS_INT(h) long   0x7ffd107d1a48 class REG NA
Interval  1: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #14  @37  RefTypeDef <Ivl:1> CNS_INT BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N036.t5. CNS_INT }
N038 (???,???) [000042] -----------                         *  PUTARG_REG long   REG rcx
<RefPosition #15  @38  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #16  @38  RefTypeUse <Ivl:1> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
Interval  2: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #17  @39  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #18  @39  RefTypeDef <Ivl:2> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>

DefList: { N038.t42. PUTARG_REG }
N040 (  1,  1) [000004] -----------                         *  CNS_INT   long   3 REG NA
Interval  3: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #19  @41  RefTypeDef <Ivl:3> CNS_INT BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N038.t42. PUTARG_REG; N040.t4. CNS_INT }
N042 (???,???) [000043] -----------                         *  PUTARG_REG long   REG rdx
<RefPosition #20  @42  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #21  @42  RefTypeUse <Ivl:3> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
Interval  4: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #22  @43  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #23  @43  RefTypeDef <Ivl:4> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>

DefList: { N038.t42. PUTARG_REG; N042.t43. PUTARG_REG }
N044 ( 18, 18) [000006] --CXG------                         *  CALL help ref    CORINFO_HELP_NEWARR_1_VC REG NA
<RefPosition #24  @44  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #25  @44  RefTypeUse <Ivl:2> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #26  @44  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #27  @44  RefTypeUse <Ivl:4> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #28  @45  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #29  @45  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #30  @45  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #31  @45  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #32  @45  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 wt=100.00>
<RefPosition #33  @45  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 wt=100.00>
<RefPosition #34  @45  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 wt=100.00>
Interval  5: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #35  @45  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #36  @45  RefTypeDef <Ivl:5> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>

DefList: { N044.t6. CALL }
N046 ( 22, 21) [000007] DA-XG------                         *  STORE_LCL_VAR ref    V04 tmp1          NA REG NA
<RefPosition #37  @46  RefTypeUse <Ivl:5> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>

DefList: {  }
N048 (???,???) [000037] -----------                         *  IL_OFFSET void   INLRT @ 0x00D[--] REG NA

DefList: {  }
N050 (  3, 10) [000010] H----------                         *  CNS_INT(h) long   0x7ffd107d1db0 field REG NA
Interval  6: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #38  @51  RefTypeDef <Ivl:6> CNS_INT BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N050.t10. CNS_INT }
N052 (???,???) [000044] -----------                         *  PUTARG_REG long   REG rcx
<RefPosition #39  @52  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #40  @52  RefTypeUse <Ivl:6> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
Interval  7: long RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #41  @53  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #42  @53  RefTypeDef <Ivl:7> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>

DefList: { N052.t44. PUTARG_REG }
N054 ( 17, 16) [000011] --CXG------                         *  CALL help ref    CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD REG NA
<RefPosition #43  @54  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #44  @54  RefTypeUse <Ivl:7> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #45  @55  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #46  @55  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #47  @55  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #48  @55  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #49  @55  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 wt=100.00>
<RefPosition #50  @55  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 wt=100.00>
<RefPosition #51  @55  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 wt=100.00>
Interval  8: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #52  @55  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #53  @55  RefTypeDef <Ivl:8> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>

DefList: { N054.t11. CALL }
N056 ( 27, 23) [000013] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2          NA REG NA
<RefPosition #54  @56  RefTypeUse <Ivl:8> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>

DefList: {  }
N058 (  3,  2) [000009] -----------                         *  LCL_VAR   ref    V04 tmp1          NA REG NA
Interval  9: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #55  @59  RefTypeDef <Ivl:9> LCL_VAR BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N058.t9. LCL_VAR }
N060 (???,???) [000045] -----------                         *  PUTARG_REG ref    REG rcx
<RefPosition #56  @60  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #57  @60  RefTypeUse <Ivl:9> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
Interval 10: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #58  @61  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #59  @61  RefTypeDef <Ivl:10> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>

DefList: { N060.t45. PUTARG_REG }
N062 (  3,  4) [000014] -----------                         *  LCL_FLD   ref    V05 tmp2         [+0] NA REG NA
Interval 11: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #60  @63  RefTypeDef <Ivl:11> LCL_FLD BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N060.t45. PUTARG_REG; N062.t14. LCL_FLD }
N064 (???,???) [000046] -----------                         *  PUTARG_REG ref    REG rdx
<RefPosition #61  @64  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #62  @64  RefTypeUse <Ivl:11> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
Interval 12: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #63  @65  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #64  @65  RefTypeDef <Ivl:12> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>

DefList: { N060.t45. PUTARG_REG; N064.t46. PUTARG_REG }
N066 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle) REG NA
<RefPosition #65  @66  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #66  @66  RefTypeUse <Ivl:10> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #67  @66  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #68  @66  RefTypeUse <Ivl:12> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #69  @67  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #70  @67  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #71  @67  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #72  @67  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #73  @67  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 wt=100.00>
<RefPosition #74  @67  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 wt=100.00>
<RefPosition #75  @67  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 wt=100.00>

DefList: {  }
N068 (???,???) [000038] -----------                         *  IL_OFFSET void   INLRT @ 0x018[--] REG NA

DefList: {  }
N070 (  3,  2) [000008] -----------                         *  LCL_VAR   ref    V04 tmp1          NA REG NA
Interval 13: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #76  @71  RefTypeDef <Ivl:13> LCL_VAR BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N070.t8. LCL_VAR }
N072 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1          NA REG NA
<RefPosition #77  @72  RefTypeUse <Ivl:13> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>

DefList: {  }
N074 (???,???) [000039] -----------                         *  IL_OFFSET void   INLRT @ 0x019[E-] REG NA

DefList: {  }
N076 (  3,  2) [000016] -----------                         *  LCL_VAR   ref    V01 loc0          NA REG NA
Interval 14: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #78  @77  RefTypeDef <Ivl:14> LCL_VAR BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N076.t16. LCL_VAR }
N078 (???,???) [000047] -----------                         *  PUTARG_REG ref    REG rcx
<RefPosition #79  @78  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #80  @78  RefTypeUse <Ivl:14> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
Interval 15: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #81  @79  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #82  @79  RefTypeDef <Ivl:15> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>

DefList: { N078.t47. PUTARG_REG }
N080 (  3,  2) [000017] -----------                         *  LCL_VAR   ref    V02 loc1          NA REG NA
Interval 16: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #83  @81  RefTypeDef <Ivl:16> LCL_VAR BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N078.t47. PUTARG_REG; N080.t17. LCL_VAR }
N082 (???,???) [000048] -----------                         *  PUTARG_REG ref    REG rdx
<RefPosition #84  @82  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #85  @82  RefTypeUse <Ivl:16> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
Interval 17: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #86  @83  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #87  @83  RefTypeDef <Ivl:17> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>

DefList: { N078.t47. PUTARG_REG; N082.t48. PUTARG_REG }
N084 (  1,  1) [000018] -----------                         *  CNS_INT   int    1 REG NA
Interval 18: int RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #88  @85  RefTypeDef <Ivl:18> CNS_INT BB05 regmask=[allIntButFP] minReg=1 wt=400.00>

DefList: { N078.t47. PUTARG_REG; N082.t48. PUTARG_REG; N084.t18. CNS_INT }
N086 (???,???) [000049] -----------                         *  PUTARG_REG int    REG r8
<RefPosition #89  @86  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #90  @86  RefTypeUse <Ivl:18> BB05 regmask=[r8] minReg=1 last fixed wt=100.00>
Interval 19: int RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #91  @87  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #92  @87  RefTypeDef <Ivl:19> PUTARG_REG BB05 regmask=[r8] minReg=1 fixed wt=400.00>

DefList: { N078.t47. PUTARG_REG; N082.t48. PUTARG_REG; N086.t49. PUTARG_REG }
N088 (  3, 10) [000050] Hc---------                         *  CNS_INT(h) long   0x7ffd10624cd8 ftn REG NA
Contained
DefList: { N078.t47. PUTARG_REG; N082.t48. PUTARG_REG; N086.t49. PUTARG_REG }
N090 (  5, 12) [000051] nc--G------                         *  IND       long   REG NA
Contained
DefList: { N078.t47. PUTARG_REG; N082.t48. PUTARG_REG; N086.t49. PUTARG_REG }
N092 ( 21, 13) [000019] --CXG------                         *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[] REG NA
<RefPosition #93  @92  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #94  @92  RefTypeUse <Ivl:15> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #95  @92  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #96  @92  RefTypeUse <Ivl:17> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #97  @92  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #98  @92  RefTypeUse <Ivl:19> BB05 regmask=[r8] minReg=1 last fixed wt=100.00>
<RefPosition #99  @93  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #100 @93  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #101 @93  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #102 @93  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #103 @93  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 wt=100.00>
<RefPosition #104 @93  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 wt=100.00>
<RefPosition #105 @93  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 wt=100.00>
Interval 20: ref RefPositions {} physReg:NA Preferences=[allIntButFP]
<RefPosition #106 @93  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #107 @93  RefTypeDef <Ivl:20> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>

DefList: { N092.t19. CALL }
N094 ( 25, 16) [000020] DA-XG------                         *  STORE_LCL_VAR ref    V06 tmp3          NA REG NA
<RefPosition #108 @94  RefTypeUse <Ivl:20> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>

DefList: {  }
N096 (???,???) [000040] -----------                         *  IL_OFFSET void   INLRT @ 0x021[--] REG NA

DefList: {  }
N098 (  0,  0) [000022] -----------                         *  NOP       void   REG NA

DefList: {  }
N100 (???,???) [000041] -----------                         *  IL_OFFSET void   INLRT @ 0x022[E-] REG NA

DefList: {  }
N102 (  0,  0) [000023] -----------                         *  RETURN    void   REG NA


Linear scan intervals BEFORE VALIDATING INTERVALS:
Interval  0: ref (constant) RefPositions {#12@31 #13@32} physReg:NA Preferences=[allIntButFP]
Interval  1: long (constant) RefPositions {#14@37 #16@38} physReg:NA Preferences=[rcx]
Interval  2: long RefPositions {#18@39 #25@44} physReg:NA Preferences=[rcx]
Interval  3: long (constant) RefPositions {#19@41 #21@42} physReg:NA Preferences=[rdx]
Interval  4: long RefPositions {#23@43 #27@44} physReg:NA Preferences=[rdx]
Interval  5: ref RefPositions {#36@45 #37@46} physReg:NA Preferences=[rax]
Interval  6: long (constant) RefPositions {#38@51 #40@52} physReg:NA Preferences=[rcx]
Interval  7: long RefPositions {#42@53 #44@54} physReg:NA Preferences=[rcx]
Interval  8: ref RefPositions {#53@55 #54@56} physReg:NA Preferences=[rax]
Interval  9: ref RefPositions {#55@59 #57@60} physReg:NA Preferences=[rcx]
Interval 10: ref RefPositions {#59@61 #66@66} physReg:NA Preferences=[rcx]
Interval 11: ref RefPositions {#60@63 #62@64} physReg:NA Preferences=[rdx]
Interval 12: ref RefPositions {#64@65 #68@66} physReg:NA Preferences=[rdx]
Interval 13: ref RefPositions {#76@71 #77@72} physReg:NA Preferences=[allIntButFP]
Interval 14: ref RefPositions {#78@77 #80@78} physReg:NA Preferences=[rcx]
Interval 15: ref RefPositions {#82@79 #94@92} physReg:NA Preferences=[rcx]
Interval 16: ref RefPositions {#83@81 #85@82} physReg:NA Preferences=[rdx]
Interval 17: ref RefPositions {#87@83 #96@92} physReg:NA Preferences=[rdx]
Interval 18: int (constant) RefPositions {#88@85 #90@86} physReg:NA Preferences=[r8]
Interval 19: int RefPositions {#92@87 #98@92} physReg:NA Preferences=[r8]
Interval 20: ref RefPositions {#107@93 #108@94} physReg:NA Preferences=[rax]

------------
REFPOSITIONS BEFORE VALIDATING INTERVALS: 
------------
<RefPosition #0   @0   RefTypeBB BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #1   @4   RefTypeBB BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #2   @16  RefTypeBB BB03 regmask=[] minReg=1 wt=50.00>
<RefPosition #3   @19  RefTypeKill <Reg:rax> BB03 regmask=[rax] minReg=1 last wt=50.00>
<RefPosition #4   @19  RefTypeKill <Reg:rcx> BB03 regmask=[rcx] minReg=1 last wt=50.00>
<RefPosition #5   @19  RefTypeKill <Reg:rdx> BB03 regmask=[rdx] minReg=1 last wt=50.00>
<RefPosition #6   @19  RefTypeKill <Reg:r8 > BB03 regmask=[r8] minReg=1 last wt=50.00>
<RefPosition #7   @19  RefTypeKill <Reg:r9 > BB03 regmask=[r9] minReg=1 last wt=50.00>
<RefPosition #8   @19  RefTypeKill <Reg:r10> BB03 regmask=[r10] minReg=1 last wt=50.00>
<RefPosition #9   @19  RefTypeKill <Reg:r11> BB03 regmask=[r11] minReg=1 last wt=50.00>
<RefPosition #10  @20  RefTypeBB BB04 regmask=[] minReg=1 wt=100.00>
<RefPosition #11  @22  RefTypeBB BB05 regmask=[] minReg=1 wt=100.00>
<RefPosition #12  @31  RefTypeDef <Ivl:0> CNS_INT BB05 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #13  @32  RefTypeUse <Ivl:0> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #14  @37  RefTypeDef <Ivl:1> CNS_INT BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #15  @38  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #16  @38  RefTypeUse <Ivl:1> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #17  @39  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #18  @39  RefTypeDef <Ivl:2> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #19  @41  RefTypeDef <Ivl:3> CNS_INT BB05 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #20  @42  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #21  @42  RefTypeUse <Ivl:3> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #22  @43  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #23  @43  RefTypeDef <Ivl:4> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #24  @44  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #25  @44  RefTypeUse <Ivl:2> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #26  @44  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #27  @44  RefTypeUse <Ivl:4> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #28  @45  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #29  @45  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #30  @45  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #31  @45  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #32  @45  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #33  @45  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #34  @45  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #35  @45  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #36  @45  RefTypeDef <Ivl:5> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #37  @46  RefTypeUse <Ivl:5> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #38  @51  RefTypeDef <Ivl:6> CNS_INT BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #39  @52  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #40  @52  RefTypeUse <Ivl:6> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #41  @53  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #42  @53  RefTypeDef <Ivl:7> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #43  @54  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #44  @54  RefTypeUse <Ivl:7> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #45  @55  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #46  @55  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #47  @55  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #48  @55  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #49  @55  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #50  @55  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #51  @55  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #52  @55  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #53  @55  RefTypeDef <Ivl:8> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #54  @56  RefTypeUse <Ivl:8> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #55  @59  RefTypeDef <Ivl:9> LCL_VAR BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #56  @60  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #57  @60  RefTypeUse <Ivl:9> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #58  @61  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #59  @61  RefTypeDef <Ivl:10> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #60  @63  RefTypeDef <Ivl:11> LCL_FLD BB05 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #61  @64  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #62  @64  RefTypeUse <Ivl:11> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #63  @65  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #64  @65  RefTypeDef <Ivl:12> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #65  @66  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #66  @66  RefTypeUse <Ivl:10> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #67  @66  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #68  @66  RefTypeUse <Ivl:12> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #69  @67  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #70  @67  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #71  @67  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #72  @67  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #73  @67  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #74  @67  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #75  @67  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #76  @71  RefTypeDef <Ivl:13> LCL_VAR BB05 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #77  @72  RefTypeUse <Ivl:13> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #78  @77  RefTypeDef <Ivl:14> LCL_VAR BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #79  @78  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #80  @78  RefTypeUse <Ivl:14> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #81  @79  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #82  @79  RefTypeDef <Ivl:15> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #83  @81  RefTypeDef <Ivl:16> LCL_VAR BB05 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #84  @82  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #85  @82  RefTypeUse <Ivl:16> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #86  @83  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #87  @83  RefTypeDef <Ivl:17> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #88  @85  RefTypeDef <Ivl:18> CNS_INT BB05 regmask=[r8] minReg=1 wt=400.00>
<RefPosition #89  @86  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #90  @86  RefTypeUse <Ivl:18> BB05 regmask=[r8] minReg=1 last fixed wt=100.00>
<RefPosition #91  @87  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #92  @87  RefTypeDef <Ivl:19> PUTARG_REG BB05 regmask=[r8] minReg=1 fixed wt=400.00>
<RefPosition #93  @92  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #94  @92  RefTypeUse <Ivl:15> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #95  @92  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #96  @92  RefTypeUse <Ivl:17> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #97  @92  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #98  @92  RefTypeUse <Ivl:19> BB05 regmask=[r8] minReg=1 last fixed wt=100.00>
<RefPosition #99  @93  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #100 @93  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #101 @93  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #102 @93  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #103 @93  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #104 @93  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #105 @93  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #106 @93  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #107 @93  RefTypeDef <Ivl:20> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #108 @94  RefTypeUse <Ivl:20> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>
TUPLE STYLE DUMP WITH REF POSITIONS
Incoming Parameters: 
BB01 [???..???), preds={} succs={BB02}
=====
  N002.                    NOP      

BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}
=====
  N006.                    CNS_INT(h) 0x7ffd10611d48 global ptr
  N008.                    IND      
  N010.                    CNS_INT   0
  N012.                    CMP      
  N014.                    JCC       cond=UEQ

BB03 [???..???), preds={BB02} succs={BB04}
=====
  N018.                    CALL help
        Kill: rax rcx rdx r8 r9 r10 r11 

BB04 [???..???), preds={BB02,BB03} succs={BB05}
=====

BB05 [000..023) (return), preds={BB04} succs={}
=====
  N024.                    IL_OFFSET INLRT @ 0x000[E-]
  N026.                    NO_OP    
  N028.                    IL_OFFSET INLRT @ 0x001[E-]
  N030.                    CNS_INT(h)  'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

        Def:<I0>(#12)
  N032.                    V01 MEM
                               Use:<I0>(#13) *
  N034.                    IL_OFFSET INLRT @ 0x007[E-]
  N036.                    CNS_INT(h) 0x7ffd107d1a48 class
        Def:<I1>(#14)
  N038.                    PUTARG_REG
                               Use:<I1>(#16) Fixed:rcx(#15) *
        Def:<I2>(#18) rcx
  N040.                    CNS_INT   3
        Def:<I3>(#19)
  N042.                    PUTARG_REG
                               Use:<I3>(#21) Fixed:rdx(#20) *
        Def:<I4>(#23) rdx
  N044.                    CALL help
                               Use:<I2>(#25) Fixed:rcx(#24) *
                               Use:<I4>(#27) Fixed:rdx(#26) *
        Kill: rax rcx rdx r8 r9 r10 r11 
        Def:<I5>(#36) rax
  N046.                    V04 MEM
                               Use:<I5>(#37) *
  N048.                    IL_OFFSET INLRT @ 0x00D[--]
  N050.                    CNS_INT(h) 0x7ffd107d1db0 field
        Def:<I6>(#38)
  N052.                    PUTARG_REG
                               Use:<I6>(#40) Fixed:rcx(#39) *
        Def:<I7>(#42) rcx
  N054.                    CALL help
                               Use:<I7>(#44) Fixed:rcx(#43) *
        Kill: rax rcx rdx r8 r9 r10 r11 
        Def:<I8>(#53) rax
  N056.                    V05 MEM
                               Use:<I8>(#54) *
  N058.                    V04 MEM
        Def:<I9>(#55)
  N060.                    PUTARG_REG
                               Use:<I9>(#57) Fixed:rcx(#56) *
        Def:<I10>(#59) rcx
  N062.                    V05 MEM
        Def:<I11>(#60)
  N064.                    PUTARG_REG
                               Use:<I11>(#62) Fixed:rdx(#61) *
        Def:<I12>(#64) rdx
  N066.                    CALL     
                               Use:<I10>(#66) Fixed:rcx(#65) *
                               Use:<I12>(#68) Fixed:rdx(#67) *
        Kill: rax rcx rdx r8 r9 r10 r11 
  N068.                    IL_OFFSET INLRT @ 0x018[--]
  N070.                    V04 MEM
        Def:<I13>(#76)
  N072.                    V02 MEM
                               Use:<I13>(#77) *
  N074.                    IL_OFFSET INLRT @ 0x019[E-]
  N076.                    V01 MEM
        Def:<I14>(#78)
  N078.                    PUTARG_REG
                               Use:<I14>(#80) Fixed:rcx(#79) *
        Def:<I15>(#82) rcx
  N080.                    V02 MEM
        Def:<I16>(#83)
  N082.                    PUTARG_REG
                               Use:<I16>(#85) Fixed:rdx(#84) *
        Def:<I17>(#87) rdx
  N084.                    CNS_INT   1
        Def:<I18>(#88)
  N086.                    PUTARG_REG
                               Use:<I18>(#90) Fixed:r8(#89) *
        Def:<I19>(#92) r8
  N088.                    CNS_INT(h) 0x7ffd10624cd8 ftn
  N090.                    IND      
  N092.                    CALL     
                               Use:<I15>(#94) Fixed:rcx(#93) *
                               Use:<I17>(#96) Fixed:rdx(#95) *
                               Use:<I19>(#98) Fixed:r8(#97) *
        Kill: rax rcx rdx r8 r9 r10 r11 
        Def:<I20>(#107) rax
  N094.                    V06 MEM
                               Use:<I20>(#108) *
  N096.                    IL_OFFSET INLRT @ 0x021[--]
  N098.                    NOP      
  N100.                    IL_OFFSET INLRT @ 0x022[E-]
  N102.                    RETURN   




Linear scan intervals after buildIntervals:
Interval  0: ref (constant) RefPositions {#12@31 #13@32} physReg:NA Preferences=[allIntButFP]
Interval  1: long (constant) RefPositions {#14@37 #16@38} physReg:NA Preferences=[rcx]
Interval  2: long RefPositions {#18@39 #25@44} physReg:NA Preferences=[rcx]
Interval  3: long (constant) RefPositions {#19@41 #21@42} physReg:NA Preferences=[rdx]
Interval  4: long RefPositions {#23@43 #27@44} physReg:NA Preferences=[rdx]
Interval  5: ref RefPositions {#36@45 #37@46} physReg:NA Preferences=[rax]
Interval  6: long (constant) RefPositions {#38@51 #40@52} physReg:NA Preferences=[rcx]
Interval  7: long RefPositions {#42@53 #44@54} physReg:NA Preferences=[rcx]
Interval  8: ref RefPositions {#53@55 #54@56} physReg:NA Preferences=[rax]
Interval  9: ref RefPositions {#55@59 #57@60} physReg:NA Preferences=[rcx]
Interval 10: ref RefPositions {#59@61 #66@66} physReg:NA Preferences=[rcx]
Interval 11: ref RefPositions {#60@63 #62@64} physReg:NA Preferences=[rdx]
Interval 12: ref RefPositions {#64@65 #68@66} physReg:NA Preferences=[rdx]
Interval 13: ref RefPositions {#76@71 #77@72} physReg:NA Preferences=[allIntButFP]
Interval 14: ref RefPositions {#78@77 #80@78} physReg:NA Preferences=[rcx]
Interval 15: ref RefPositions {#82@79 #94@92} physReg:NA Preferences=[rcx]
Interval 16: ref RefPositions {#83@81 #85@82} physReg:NA Preferences=[rdx]
Interval 17: ref RefPositions {#87@83 #96@92} physReg:NA Preferences=[rdx]
Interval 18: int (constant) RefPositions {#88@85 #90@86} physReg:NA Preferences=[r8]
Interval 19: int RefPositions {#92@87 #98@92} physReg:NA Preferences=[r8]
Interval 20: ref RefPositions {#107@93 #108@94} physReg:NA Preferences=[rax]

*************** In LinearScan::allocateRegisters()

Linear scan intervals before allocateRegisters:
Interval  0: ref (constant) RefPositions {#12@31 #13@32} physReg:NA Preferences=[allIntButFP]
Interval  1: long (constant) RefPositions {#14@37 #16@38} physReg:NA Preferences=[rcx]
Interval  2: long RefPositions {#18@39 #25@44} physReg:NA Preferences=[rcx]
Interval  3: long (constant) RefPositions {#19@41 #21@42} physReg:NA Preferences=[rdx]
Interval  4: long RefPositions {#23@43 #27@44} physReg:NA Preferences=[rdx]
Interval  5: ref RefPositions {#36@45 #37@46} physReg:NA Preferences=[rax]
Interval  6: long (constant) RefPositions {#38@51 #40@52} physReg:NA Preferences=[rcx]
Interval  7: long RefPositions {#42@53 #44@54} physReg:NA Preferences=[rcx]
Interval  8: ref RefPositions {#53@55 #54@56} physReg:NA Preferences=[rax]
Interval  9: ref RefPositions {#55@59 #57@60} physReg:NA Preferences=[rcx]
Interval 10: ref RefPositions {#59@61 #66@66} physReg:NA Preferences=[rcx]
Interval 11: ref RefPositions {#60@63 #62@64} physReg:NA Preferences=[rdx]
Interval 12: ref RefPositions {#64@65 #68@66} physReg:NA Preferences=[rdx]
Interval 13: ref RefPositions {#76@71 #77@72} physReg:NA Preferences=[allIntButFP]
Interval 14: ref RefPositions {#78@77 #80@78} physReg:NA Preferences=[rcx]
Interval 15: ref RefPositions {#82@79 #94@92} physReg:NA Preferences=[rcx]
Interval 16: ref RefPositions {#83@81 #85@82} physReg:NA Preferences=[rdx]
Interval 17: ref RefPositions {#87@83 #96@92} physReg:NA Preferences=[rdx]
Interval 18: int (constant) RefPositions {#88@85 #90@86} physReg:NA Preferences=[r8]
Interval 19: int RefPositions {#92@87 #98@92} physReg:NA Preferences=[r8]
Interval 20: ref RefPositions {#107@93 #108@94} physReg:NA Preferences=[rax]

------------
REFPOSITIONS BEFORE ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeBB BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #1   @4   RefTypeBB BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #2   @16  RefTypeBB BB03 regmask=[] minReg=1 wt=50.00>
<RefPosition #3   @19  RefTypeKill <Reg:rax> BB03 regmask=[rax] minReg=1 last wt=50.00>
<RefPosition #4   @19  RefTypeKill <Reg:rcx> BB03 regmask=[rcx] minReg=1 last wt=50.00>
<RefPosition #5   @19  RefTypeKill <Reg:rdx> BB03 regmask=[rdx] minReg=1 last wt=50.00>
<RefPosition #6   @19  RefTypeKill <Reg:r8 > BB03 regmask=[r8] minReg=1 last wt=50.00>
<RefPosition #7   @19  RefTypeKill <Reg:r9 > BB03 regmask=[r9] minReg=1 last wt=50.00>
<RefPosition #8   @19  RefTypeKill <Reg:r10> BB03 regmask=[r10] minReg=1 last wt=50.00>
<RefPosition #9   @19  RefTypeKill <Reg:r11> BB03 regmask=[r11] minReg=1 last wt=50.00>
<RefPosition #10  @20  RefTypeBB BB04 regmask=[] minReg=1 wt=100.00>
<RefPosition #11  @22  RefTypeBB BB05 regmask=[] minReg=1 wt=100.00>
<RefPosition #12  @31  RefTypeDef <Ivl:0> CNS_INT BB05 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #13  @32  RefTypeUse <Ivl:0> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #14  @37  RefTypeDef <Ivl:1> CNS_INT BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #15  @38  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #16  @38  RefTypeUse <Ivl:1> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #17  @39  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #18  @39  RefTypeDef <Ivl:2> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #19  @41  RefTypeDef <Ivl:3> CNS_INT BB05 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #20  @42  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #21  @42  RefTypeUse <Ivl:3> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #22  @43  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #23  @43  RefTypeDef <Ivl:4> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #24  @44  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #25  @44  RefTypeUse <Ivl:2> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #26  @44  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #27  @44  RefTypeUse <Ivl:4> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #28  @45  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #29  @45  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #30  @45  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #31  @45  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #32  @45  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #33  @45  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #34  @45  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #35  @45  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #36  @45  RefTypeDef <Ivl:5> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #37  @46  RefTypeUse <Ivl:5> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #38  @51  RefTypeDef <Ivl:6> CNS_INT BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #39  @52  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #40  @52  RefTypeUse <Ivl:6> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #41  @53  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #42  @53  RefTypeDef <Ivl:7> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #43  @54  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #44  @54  RefTypeUse <Ivl:7> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #45  @55  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #46  @55  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #47  @55  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #48  @55  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #49  @55  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #50  @55  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #51  @55  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #52  @55  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #53  @55  RefTypeDef <Ivl:8> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #54  @56  RefTypeUse <Ivl:8> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #55  @59  RefTypeDef <Ivl:9> LCL_VAR BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #56  @60  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #57  @60  RefTypeUse <Ivl:9> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #58  @61  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #59  @61  RefTypeDef <Ivl:10> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #60  @63  RefTypeDef <Ivl:11> LCL_FLD BB05 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #61  @64  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #62  @64  RefTypeUse <Ivl:11> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #63  @65  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #64  @65  RefTypeDef <Ivl:12> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #65  @66  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #66  @66  RefTypeUse <Ivl:10> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #67  @66  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #68  @66  RefTypeUse <Ivl:12> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #69  @67  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #70  @67  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #71  @67  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #72  @67  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #73  @67  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #74  @67  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #75  @67  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #76  @71  RefTypeDef <Ivl:13> LCL_VAR BB05 regmask=[allIntButFP] minReg=1 wt=400.00>
<RefPosition #77  @72  RefTypeUse <Ivl:13> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>
<RefPosition #78  @77  RefTypeDef <Ivl:14> LCL_VAR BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #79  @78  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #80  @78  RefTypeUse <Ivl:14> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #81  @79  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #82  @79  RefTypeDef <Ivl:15> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #83  @81  RefTypeDef <Ivl:16> LCL_VAR BB05 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #84  @82  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #85  @82  RefTypeUse <Ivl:16> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #86  @83  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #87  @83  RefTypeDef <Ivl:17> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #88  @85  RefTypeDef <Ivl:18> CNS_INT BB05 regmask=[r8] minReg=1 wt=400.00>
<RefPosition #89  @86  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #90  @86  RefTypeUse <Ivl:18> BB05 regmask=[r8] minReg=1 last fixed wt=100.00>
<RefPosition #91  @87  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #92  @87  RefTypeDef <Ivl:19> PUTARG_REG BB05 regmask=[r8] minReg=1 fixed wt=400.00>
<RefPosition #93  @92  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #94  @92  RefTypeUse <Ivl:15> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #95  @92  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #96  @92  RefTypeUse <Ivl:17> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #97  @92  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #98  @92  RefTypeUse <Ivl:19> BB05 regmask=[r8] minReg=1 last fixed wt=100.00>
<RefPosition #99  @93  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #100 @93  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #101 @93  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #102 @93  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #103 @93  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #104 @93  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #105 @93  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #106 @93  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #107 @93  RefTypeDef <Ivl:20> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #108 @94  RefTypeUse <Ivl:20> BB05 regmask=[allIntButFP] minReg=1 last wt=100.00>


Allocating Registers
--------------------
The following table has one or more rows for each RefPosition that is handled during allocation.
The columns are: (1) Loc: LSRA location, (2) RP#: RefPosition number, (3) Name, (4) Type (e.g. Def, Use,
Fixd, Parm, DDef (Dummy Def), ExpU (Exposed Use), Kill) followed by a '*' if it is a last use, and a 'D'
if it is delayRegFree, (5) Action taken during allocation. Some actions include (a) Alloc a new register,
(b) Keep an existing register, (c) Spill a register, (d) ReLod (Reload) a register. If an ALL-CAPS name
such as COVRS is displayed, it is a score name from lsra_score.h, with a trailing '(A)' indicating alloc,
'(C)' indicating copy, and '(R)' indicating re-use. See dumpLsraAllocationEvent() for details.
The subsequent columns show the Interval occupying each register, if any, followed by 'a' if it is
active, 'p' if it is a large vector that has been partially spilled, and 'i' if it is inactive.
Columns are only printed up to the last modified register, which may increase during allocation,
in which case additional columns will appear. Registers which are not marked modified have ---- in
their column.

--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
                                            |    |    |    |    |    |    |    |    |    |
           0.#0   BB1 PredBB0               |    |    |    |    |    |    |    |    |    |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
           4.#1   BB2 PredBB1               |    |    |    |    |    |    |    |    |    |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
          16.#2   BB3 PredBB2               |    |    |    |    |    |    |    |    |    |
[000028]  19.#3   rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          19.#4   rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          19.#5   rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          19.#6   r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          19.#7   r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          19.#8   r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          19.#9   r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
          20.#10  BB4 PredBB2               |    |    |    |    |    |    |    |    |    |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
          22.#11  BB5 PredBB4               |    |    |    |    |    |    |    |    |    |
[000032]  31.#12  C0   Def    BSFIT(A) rcx  |    |C0 a|    |    |    |    |    |    |    |
[000003]  32.#13  C0   Use *  Keep     rcx  |    |C0 a|    |    |    |    |    |    |    |
[000005]  37.#14  C1   Def    Alloc    rcx  |    |C1 a|    |    |    |    |    |    |    |
[000042]  38.#15  rcx  Fixd   Keep     rcx  |    |C1 a|    |    |    |    |    |    |    |
          38.#16  C1   Use *  Keep     rcx  |    |C1 a|    |    |    |    |    |    |    |
          39.#17  rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          39.#18  I2   Def    Alloc    rcx  |    |I2 a|    |    |    |    |    |    |    |
[000004]  41.#19  C3   Def    Alloc    rdx  |    |I2 a|C3 a|    |    |    |    |    |    |
[000043]  42.#20  rdx  Fixd   Keep     rdx  |    |I2 a|C3 a|    |    |    |    |    |    |
          42.#21  C3   Use *  Keep     rdx  |    |I2 a|C3 a|    |    |    |    |    |    |
          43.#22  rdx  Fixd   Keep     rdx  |    |I2 a|    |    |    |    |    |    |    |
          43.#23  I4   Def    Alloc    rdx  |    |I2 a|I4 a|    |    |    |    |    |    |
[000006]  44.#24  rcx  Fixd   Keep     rcx  |    |I2 a|I4 a|    |    |    |    |    |    |
          44.#25  I2   Use *  Keep     rcx  |    |I2 a|I4 a|    |    |    |    |    |    |
          44.#26  rdx  Fixd   Keep     rdx  |    |I2 a|I4 a|    |    |    |    |    |    |
          44.#27  I4   Use *  Keep     rdx  |    |I2 a|I4 a|    |    |    |    |    |    |
          45.#28  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          45.#29  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          45.#30  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          45.#31  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          45.#32  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          45.#33  r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          45.#34  r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
          45.#35  rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
          45.#36  I5   Def    Alloc    rax  |I5 a|    |    |    |    |    |    |    |    |
[000007]  46.#37  I5   Use *  Keep     rax  |I5 a|    |    |    |    |    |    |    |    |
[000010]  51.#38  C6   Def    Alloc    rcx  |    |C6 a|    |    |    |    |    |    |    |
[000044]  52.#39  rcx  Fixd   Keep     rcx  |    |C6 a|    |    |    |    |    |    |    |
          52.#40  C6   Use *  Keep     rcx  |    |C6 a|    |    |    |    |    |    |    |
          53.#41  rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          53.#42  I7   Def    Alloc    rcx  |    |I7 a|    |    |    |    |    |    |    |
[000011]  54.#43  rcx  Fixd   Keep     rcx  |    |I7 a|    |    |    |    |    |    |    |
          54.#44  I7   Use *  Keep     rcx  |    |I7 a|    |    |    |    |    |    |    |
          55.#45  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          55.#46  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          55.#47  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          55.#48  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          55.#49  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          55.#50  r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          55.#51  r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
          55.#52  rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
          55.#53  I8   Def    Alloc    rax  |I8 a|    |    |    |    |    |    |    |    |
[000013]  56.#54  I8   Use *  Keep     rax  |I8 a|    |    |    |    |    |    |    |    |
[000009]  59.#55  I9   Def    Alloc    rcx  |    |I9 a|    |    |    |    |    |    |    |
[000045]  60.#56  rcx  Fixd   Keep     rcx  |    |I9 a|    |    |    |    |    |    |    |
          60.#57  I9   Use *  Keep     rcx  |    |I9 a|    |    |    |    |    |    |    |
          61.#58  rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          61.#59  I10  Def    Alloc    rcx  |    |I10a|    |    |    |    |    |    |    |
[000014]  63.#60  I11  Def    Alloc    rdx  |    |I10a|I11a|    |    |    |    |    |    |
[000046]  64.#61  rdx  Fixd   Keep     rdx  |    |I10a|I11a|    |    |    |    |    |    |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
          64.#62  I11  Use *  Keep     rdx  |    |I10a|I11a|    |    |    |    |    |    |
          65.#63  rdx  Fixd   Keep     rdx  |    |I10a|    |    |    |    |    |    |    |
          65.#64  I12  Def    Alloc    rdx  |    |I10a|I12a|    |    |    |    |    |    |
[000012]  66.#65  rcx  Fixd   Keep     rcx  |    |I10a|I12a|    |    |    |    |    |    |
          66.#66  I10  Use *  Keep     rcx  |    |I10a|I12a|    |    |    |    |    |    |
          66.#67  rdx  Fixd   Keep     rdx  |    |I10a|I12a|    |    |    |    |    |    |
          66.#68  I12  Use *  Keep     rdx  |    |I10a|I12a|    |    |    |    |    |    |
          67.#69  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          67.#70  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          67.#71  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          67.#72  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          67.#73  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          67.#74  r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          67.#75  r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
[000008]  71.#76  I13  Def    BSFIT(A) rcx  |    |I13a|    |    |    |    |    |    |    |
[000015]  72.#77  I13  Use *  Keep     rcx  |    |I13a|    |    |    |    |    |    |    |
[000016]  77.#78  I14  Def    Alloc    rcx  |    |I14a|    |    |    |    |    |    |    |
[000047]  78.#79  rcx  Fixd   Keep     rcx  |    |I14a|    |    |    |    |    |    |    |
          78.#80  I14  Use *  Keep     rcx  |    |I14a|    |    |    |    |    |    |    |
          79.#81  rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          79.#82  I15  Def    Alloc    rcx  |    |I15a|    |    |    |    |    |    |    |
[000017]  81.#83  I16  Def    Alloc    rdx  |    |I15a|I16a|    |    |    |    |    |    |
[000048]  82.#84  rdx  Fixd   Keep     rdx  |    |I15a|I16a|    |    |    |    |    |    |
          82.#85  I16  Use *  Keep     rdx  |    |I15a|I16a|    |    |    |    |    |    |
          83.#86  rdx  Fixd   Keep     rdx  |    |I15a|    |    |    |    |    |    |    |
          83.#87  I17  Def    Alloc    rdx  |    |I15a|I17a|    |    |    |    |    |    |
[000018]  85.#88  C18  Def    Alloc    r8   |    |I15a|I17a|    |    |    |    |C18a|    |
[000049]  86.#89  r8   Fixd   Keep     r8   |    |I15a|I17a|    |    |    |    |C18a|    |
          86.#90  C18  Use *  Keep     r8   |    |I15a|I17a|    |    |    |    |C18a|    |
          87.#91  r8   Fixd   Keep     r8   |    |I15a|I17a|    |    |    |    |    |    |
          87.#92  I19  Def    Alloc    r8   |    |I15a|I17a|    |    |    |    |I19a|    |
[000019]  92.#93  rcx  Fixd   Keep     rcx  |    |I15a|I17a|    |    |    |    |I19a|    |
          92.#94  I15  Use *  Keep     rcx  |    |I15a|I17a|    |    |    |    |I19a|    |
          92.#95  rdx  Fixd   Keep     rdx  |    |I15a|I17a|    |    |    |    |I19a|    |
          92.#96  I17  Use *  Keep     rdx  |    |I15a|I17a|    |    |    |    |I19a|    |
          92.#97  r8   Fixd   Keep     r8   |    |I15a|I17a|    |    |    |    |I19a|    |
          92.#98  I19  Use *  Keep     r8   |    |I15a|I17a|    |    |    |    |I19a|    |
          93.#99  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          93.#100 rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          93.#101 rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          93.#102 r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          93.#103 r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          93.#104 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          93.#105 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
          93.#106 rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
          93.#107 I20  Def    Alloc    rax  |I20a|    |    |    |    |    |    |    |    |
[000020]  94.#108 I20  Use *  Keep     rax  |    |    |    |    |    |    |    |    |    |

------------
REFPOSITIONS AFTER ALLOCATION: 
------------
<RefPosition #0   @0   RefTypeBB BB01 regmask=[] minReg=1 wt=100.00>
<RefPosition #1   @4   RefTypeBB BB02 regmask=[] minReg=1 wt=100.00>
<RefPosition #2   @16  RefTypeBB BB03 regmask=[] minReg=1 wt=50.00>
<RefPosition #3   @19  RefTypeKill <Reg:rax> BB03 regmask=[rax] minReg=1 last wt=50.00>
<RefPosition #4   @19  RefTypeKill <Reg:rcx> BB03 regmask=[rcx] minReg=1 last wt=50.00>
<RefPosition #5   @19  RefTypeKill <Reg:rdx> BB03 regmask=[rdx] minReg=1 last wt=50.00>
<RefPosition #6   @19  RefTypeKill <Reg:r8 > BB03 regmask=[r8] minReg=1 last wt=50.00>
<RefPosition #7   @19  RefTypeKill <Reg:r9 > BB03 regmask=[r9] minReg=1 last wt=50.00>
<RefPosition #8   @19  RefTypeKill <Reg:r10> BB03 regmask=[r10] minReg=1 last wt=50.00>
<RefPosition #9   @19  RefTypeKill <Reg:r11> BB03 regmask=[r11] minReg=1 last wt=50.00>
<RefPosition #10  @20  RefTypeBB BB04 regmask=[] minReg=1 wt=100.00>
<RefPosition #11  @22  RefTypeBB BB05 regmask=[] minReg=1 wt=100.00>
<RefPosition #12  @31  RefTypeDef <Ivl:0> CNS_INT BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #13  @32  RefTypeUse <Ivl:0> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #14  @37  RefTypeDef <Ivl:1> CNS_INT BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #15  @38  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #16  @38  RefTypeUse <Ivl:1> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #17  @39  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #18  @39  RefTypeDef <Ivl:2> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #19  @41  RefTypeDef <Ivl:3> CNS_INT BB05 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #20  @42  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #21  @42  RefTypeUse <Ivl:3> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #22  @43  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #23  @43  RefTypeDef <Ivl:4> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #24  @44  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #25  @44  RefTypeUse <Ivl:2> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #26  @44  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #27  @44  RefTypeUse <Ivl:4> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #28  @45  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #29  @45  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #30  @45  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #31  @45  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #32  @45  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #33  @45  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #34  @45  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #35  @45  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #36  @45  RefTypeDef <Ivl:5> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #37  @46  RefTypeUse <Ivl:5> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #38  @51  RefTypeDef <Ivl:6> CNS_INT BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #39  @52  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #40  @52  RefTypeUse <Ivl:6> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #41  @53  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #42  @53  RefTypeDef <Ivl:7> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #43  @54  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #44  @54  RefTypeUse <Ivl:7> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #45  @55  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #46  @55  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #47  @55  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #48  @55  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #49  @55  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #50  @55  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #51  @55  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #52  @55  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #53  @55  RefTypeDef <Ivl:8> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #54  @56  RefTypeUse <Ivl:8> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #55  @59  RefTypeDef <Ivl:9> LCL_VAR BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #56  @60  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #57  @60  RefTypeUse <Ivl:9> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #58  @61  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #59  @61  RefTypeDef <Ivl:10> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #60  @63  RefTypeDef <Ivl:11> LCL_FLD BB05 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #61  @64  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #62  @64  RefTypeUse <Ivl:11> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #63  @65  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #64  @65  RefTypeDef <Ivl:12> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #65  @66  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #66  @66  RefTypeUse <Ivl:10> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #67  @66  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #68  @66  RefTypeUse <Ivl:12> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #69  @67  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #70  @67  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #71  @67  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #72  @67  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #73  @67  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #74  @67  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #75  @67  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #76  @71  RefTypeDef <Ivl:13> LCL_VAR BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #77  @72  RefTypeUse <Ivl:13> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #78  @77  RefTypeDef <Ivl:14> LCL_VAR BB05 regmask=[rcx] minReg=1 wt=400.00>
<RefPosition #79  @78  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #80  @78  RefTypeUse <Ivl:14> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #81  @79  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #82  @79  RefTypeDef <Ivl:15> PUTARG_REG BB05 regmask=[rcx] minReg=1 fixed wt=400.00>
<RefPosition #83  @81  RefTypeDef <Ivl:16> LCL_VAR BB05 regmask=[rdx] minReg=1 wt=400.00>
<RefPosition #84  @82  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #85  @82  RefTypeUse <Ivl:16> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #86  @83  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #87  @83  RefTypeDef <Ivl:17> PUTARG_REG BB05 regmask=[rdx] minReg=1 fixed wt=400.00>
<RefPosition #88  @85  RefTypeDef <Ivl:18> CNS_INT BB05 regmask=[r8] minReg=1 wt=400.00>
<RefPosition #89  @86  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #90  @86  RefTypeUse <Ivl:18> BB05 regmask=[r8] minReg=1 last fixed wt=100.00>
<RefPosition #91  @87  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #92  @87  RefTypeDef <Ivl:19> PUTARG_REG BB05 regmask=[r8] minReg=1 fixed wt=400.00>
<RefPosition #93  @92  RefTypeFixedReg <Reg:rcx> BB05 regmask=[rcx] minReg=1 wt=100.00>
<RefPosition #94  @92  RefTypeUse <Ivl:15> BB05 regmask=[rcx] minReg=1 last fixed wt=100.00>
<RefPosition #95  @92  RefTypeFixedReg <Reg:rdx> BB05 regmask=[rdx] minReg=1 wt=100.00>
<RefPosition #96  @92  RefTypeUse <Ivl:17> BB05 regmask=[rdx] minReg=1 last fixed wt=100.00>
<RefPosition #97  @92  RefTypeFixedReg <Reg:r8 > BB05 regmask=[r8] minReg=1 wt=100.00>
<RefPosition #98  @92  RefTypeUse <Ivl:19> BB05 regmask=[r8] minReg=1 last fixed wt=100.00>
<RefPosition #99  @93  RefTypeKill <Reg:rax> BB05 regmask=[rax] minReg=1 last wt=100.00>
<RefPosition #100 @93  RefTypeKill <Reg:rcx> BB05 regmask=[rcx] minReg=1 last wt=100.00>
<RefPosition #101 @93  RefTypeKill <Reg:rdx> BB05 regmask=[rdx] minReg=1 last wt=100.00>
<RefPosition #102 @93  RefTypeKill <Reg:r8 > BB05 regmask=[r8] minReg=1 last wt=100.00>
<RefPosition #103 @93  RefTypeKill <Reg:r9 > BB05 regmask=[r9] minReg=1 last wt=100.00>
<RefPosition #104 @93  RefTypeKill <Reg:r10> BB05 regmask=[r10] minReg=1 last wt=100.00>
<RefPosition #105 @93  RefTypeKill <Reg:r11> BB05 regmask=[r11] minReg=1 last wt=100.00>
<RefPosition #106 @93  RefTypeFixedReg <Reg:rax> BB05 regmask=[rax] minReg=1 wt=100.00>
<RefPosition #107 @93  RefTypeDef <Ivl:20> CALL BB05 regmask=[rax] minReg=1 fixed wt=400.00>
<RefPosition #108 @94  RefTypeUse <Ivl:20> BB05 regmask=[rax] minReg=1 last wt=100.00>
Active intervals at end of allocation:

Trees after linear scan register allocator (LSRA)

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall LIR 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal LIR 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal LIR 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall LIR 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N002 (  0,  0) [000000] -----------                            NOP       void   REG NA

------------ BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}
N006 (  3, 10) [000024] Hc---------                   t24 =    CNS_INT(h) long   0x7ffd10611d48 global ptr REG NA
                                                            /--*  t24    long   
N008 (  5, 12) [000025] nc--G------                   t25 = *  IND       int    REG NA
N010 (  1,  1) [000026] -c---------                   t26 =    CNS_INT   int    0 REG NA
                                                            /--*  t25    int    
                                                            +--*  t26    int    
N012 (  7, 14) [000027] ----G--N---                         *  CMP       void   REG NA
N014 (  9, 16) [000033] ----G------                            JCC       void   cond=UEQ REG NA

------------ BB03 [???..???), preds={BB02} succs={BB04}
N018 ( 14,  5) [000028] --C-G-?----                            CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE REG NA

------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}

------------ BB05 [000..023) (return), preds={BB04} succs={}
N024 (???,???) [000034] -----------                            IL_OFFSET void   INLRT @ 0x000[E-] REG NA
N026 (  1,  1) [000001] -----------                            NO_OP     void   REG NA
N028 (???,???) [000035] -----------                            IL_OFFSET void   INLRT @ 0x001[E-] REG NA
N030 (  3, 10) [000032] H----------                   t32 =    CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '
 REG rcx
                                                            /--*  t32    ref    
N032 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0          NA REG NA
N034 (???,???) [000036] -----------                            IL_OFFSET void   INLRT @ 0x007[E-] REG NA
N036 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class REG rcx
                                                            /--*  t5     long   
N038 (???,???) [000042] -----------                   t42 = *  PUTARG_REG long   REG rcx
N040 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3 REG rdx
                                                            /--*  t4     long   
N042 (???,???) [000043] -----------                   t43 = *  PUTARG_REG long   REG rdx
                                                            /--*  t42    long   arg0 in rcx
                                                            +--*  t43    long   arg1 in rdx
N044 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC REG rax
                                                            /--*  t6     ref    
N046 ( 22, 21) [000007] DA-XG------                         *  STORE_LCL_VAR ref    V04 tmp1          NA REG NA
N048 (???,???) [000037] -----------                            IL_OFFSET void   INLRT @ 0x00D[--] REG NA
N050 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field REG rcx
                                                            /--*  t10    long   
N052 (???,???) [000044] -----------                   t44 = *  PUTARG_REG long   REG rcx
                                                            /--*  t44    long   arg0 in rcx
N054 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help ref    CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD REG rax
                                                            /--*  t11    ref    
N056 ( 27, 23) [000013] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2          NA REG NA
N058 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   ref    V04 tmp1          rcx REG rcx
                                                            /--*  t9     ref    
N060 (???,???) [000045] -----------                   t45 = *  PUTARG_REG ref    REG rcx
N062 (  3,  4) [000014] -----------                   t14 =    LCL_FLD   ref    V05 tmp2         [+0] rdx REG rdx
                                                            /--*  t14    ref    
N064 (???,???) [000046] -----------                   t46 = *  PUTARG_REG ref    REG rdx
                                                            /--*  t45    ref    arg0 in rcx
                                                            +--*  t46    ref    arg1 in rdx
N066 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle) REG NA
N068 (???,???) [000038] -----------                            IL_OFFSET void   INLRT @ 0x018[--] REG NA
N070 (  3,  2) [000008] -----------                    t8 =    LCL_VAR   ref    V04 tmp1          rcx REG rcx
                                                            /--*  t8     ref    
N072 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1          NA REG NA
N074 (???,???) [000039] -----------                            IL_OFFSET void   INLRT @ 0x019[E-] REG NA
N076 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0          rcx REG rcx
                                                            /--*  t16    ref    
N078 (???,???) [000047] -----------                   t47 = *  PUTARG_REG ref    REG rcx
N080 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1          rdx REG rdx
                                                            /--*  t17    ref    
N082 (???,???) [000048] -----------                   t48 = *  PUTARG_REG ref    REG rdx
N084 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1 REG r8
                                                            /--*  t18    int    
N086 (???,???) [000049] -----------                   t49 = *  PUTARG_REG int    REG r8
N088 (  3, 10) [000050] Hc---------                   t50 =    CNS_INT(h) long   0x7ffd10624cd8 ftn REG NA
                                                            /--*  t50    long   
N090 (  5, 12) [000051] nc--G------                   t51 = *  IND       long   REG NA
                                                            /--*  t47    ref    arg0 in rcx
                                                            +--*  t48    ref    arg1 in rdx
                                                            +--*  t49    int    arg2 in r8
                                                            +--*  t51    long   control expr
N092 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[] REG rax
                                                            /--*  t19    ref    
N094 ( 25, 16) [000020] DA-XG------                         *  STORE_LCL_VAR ref    V06 tmp3          NA REG NA
N096 (???,???) [000040] -----------                            IL_OFFSET void   INLRT @ 0x021[--] REG NA
N098 (  0,  0) [000022] -----------                            NOP       void   REG NA
N100 (???,???) [000041] -----------                            IL_OFFSET void   INLRT @ 0x022[E-] REG NA
N102 (  0,  0) [000023] -----------                            RETURN    void   REG NA

-------------------------------------------------------------------------------------------------------------------

Final allocation
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
           0.#0   BB1 PredBB0               |    |    |    |    |    |    |    |    |    |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
           4.#1   BB2 PredBB1               |    |    |    |    |    |    |    |    |    |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
          16.#2   BB3 PredBB2               |    |    |    |    |    |    |    |    |    |
[000028]  19.#3   rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          19.#4   rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          19.#5   rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          19.#6   r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          19.#7   r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          19.#8   r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          19.#9   r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
          20.#10  BB4 PredBB2               |    |    |    |    |    |    |    |    |    |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
TreeID   Loc RP#  Name Type  Action    Reg  |rax |rcx |rdx |rbx |rbp |rsi |rdi |r8  |r9  |
--------------------------------------------+----+----+----+----+----+----+----+----+----+
          22.#11  BB5 PredBB4               |    |    |    |    |    |    |    |    |    |
[000032]  31.#12  C0   Def    Alloc    rcx  |    |C0 a|    |    |    |    |    |    |    |
[000003]  32.#13  C0   Use *  Keep     rcx  |    |C0 i|    |    |    |    |    |    |    |
[000005]  37.#14  C1   Def    Alloc    rcx  |    |C1 a|    |    |    |    |    |    |    |
[000042]  38.#15  rcx  Fixd   Keep     rcx  |    |C1 a|    |    |    |    |    |    |    |
          38.#16  C1   Use *  Keep     rcx  |    |C1 i|    |    |    |    |    |    |    |
          39.#17  rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          39.#18  I2   Def    Alloc    rcx  |    |I2 a|    |    |    |    |    |    |    |
[000004]  41.#19  C3   Def    Alloc    rdx  |    |I2 a|C3 a|    |    |    |    |    |    |
[000043]  42.#20  rdx  Fixd   Keep     rdx  |    |I2 a|C3 a|    |    |    |    |    |    |
          42.#21  C3   Use *  Keep     rdx  |    |I2 a|C3 i|    |    |    |    |    |    |
          43.#22  rdx  Fixd   Keep     rdx  |    |I2 a|    |    |    |    |    |    |    |
          43.#23  I4   Def    Alloc    rdx  |    |I2 a|I4 a|    |    |    |    |    |    |
[000006]  44.#24  rcx  Fixd   Keep     rcx  |    |I2 a|I4 a|    |    |    |    |    |    |
          44.#25  I2   Use *  Keep     rcx  |    |I2 i|I4 a|    |    |    |    |    |    |
          44.#26  rdx  Fixd   Keep     rdx  |    |    |I4 a|    |    |    |    |    |    |
          44.#27  I4   Use *  Keep     rdx  |    |    |I4 i|    |    |    |    |    |    |
          45.#28  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          45.#29  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          45.#30  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          45.#31  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          45.#32  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          45.#33  r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          45.#34  r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
          45.#35  rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
          45.#36  I5   Def    Alloc    rax  |I5 a|    |    |    |    |    |    |    |    |
[000007]  46.#37  I5   Use *  Keep     rax  |I5 i|    |    |    |    |    |    |    |    |
[000010]  51.#38  C6   Def    Alloc    rcx  |    |C6 a|    |    |    |    |    |    |    |
[000044]  52.#39  rcx  Fixd   Keep     rcx  |    |C6 a|    |    |    |    |    |    |    |
          52.#40  C6   Use *  Keep     rcx  |    |C6 i|    |    |    |    |    |    |    |
          53.#41  rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          53.#42  I7   Def    Alloc    rcx  |    |I7 a|    |    |    |    |    |    |    |
[000011]  54.#43  rcx  Fixd   Keep     rcx  |    |I7 a|    |    |    |    |    |    |    |
          54.#44  I7   Use *  Keep     rcx  |    |I7 i|    |    |    |    |    |    |    |
          55.#45  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          55.#46  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          55.#47  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          55.#48  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          55.#49  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          55.#50  r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          55.#51  r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
          55.#52  rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
          55.#53  I8   Def    Alloc    rax  |I8 a|    |    |    |    |    |    |    |    |
[000013]  56.#54  I8   Use *  Keep     rax  |I8 i|    |    |    |    |    |    |    |    |
[000009]  59.#55  I9   Def    Alloc    rcx  |    |I9 a|    |    |    |    |    |    |    |
[000045]  60.#56  rcx  Fixd   Keep     rcx  |    |I9 a|    |    |    |    |    |    |    |
          60.#57  I9   Use *  Keep     rcx  |    |I9 i|    |    |    |    |    |    |    |
          61.#58  rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          61.#59  I10  Def    Alloc    rcx  |    |I10a|    |    |    |    |    |    |    |
[000014]  63.#60  I11  Def    Alloc    rdx  |    |I10a|I11a|    |    |    |    |    |    |
[000046]  64.#61  rdx  Fixd   Keep     rdx  |    |I10a|I11a|    |    |    |    |    |    |
          64.#62  I11  Use *  Keep     rdx  |    |I10a|I11i|    |    |    |    |    |    |
          65.#63  rdx  Fixd   Keep     rdx  |    |I10a|    |    |    |    |    |    |    |
          65.#64  I12  Def    Alloc    rdx  |    |I10a|I12a|    |    |    |    |    |    |
[000012]  66.#65  rcx  Fixd   Keep     rcx  |    |I10a|I12a|    |    |    |    |    |    |
          66.#66  I10  Use *  Keep     rcx  |    |I10i|I12a|    |    |    |    |    |    |
          66.#67  rdx  Fixd   Keep     rdx  |    |    |I12a|    |    |    |    |    |    |
          66.#68  I12  Use *  Keep     rdx  |    |    |I12i|    |    |    |    |    |    |
          67.#69  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          67.#70  rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          67.#71  rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          67.#72  r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          67.#73  r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          67.#74  r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          67.#75  r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
[000008]  71.#76  I13  Def    Alloc    rcx  |    |I13a|    |    |    |    |    |    |    |
[000015]  72.#77  I13  Use *  Keep     rcx  |    |I13i|    |    |    |    |    |    |    |
[000016]  77.#78  I14  Def    Alloc    rcx  |    |I14a|    |    |    |    |    |    |    |
[000047]  78.#79  rcx  Fixd   Keep     rcx  |    |I14a|    |    |    |    |    |    |    |
          78.#80  I14  Use *  Keep     rcx  |    |I14i|    |    |    |    |    |    |    |
          79.#81  rcx  Fixd   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          79.#82  I15  Def    Alloc    rcx  |    |I15a|    |    |    |    |    |    |    |
[000017]  81.#83  I16  Def    Alloc    rdx  |    |I15a|I16a|    |    |    |    |    |    |
[000048]  82.#84  rdx  Fixd   Keep     rdx  |    |I15a|I16a|    |    |    |    |    |    |
          82.#85  I16  Use *  Keep     rdx  |    |I15a|I16i|    |    |    |    |    |    |
          83.#86  rdx  Fixd   Keep     rdx  |    |I15a|    |    |    |    |    |    |    |
          83.#87  I17  Def    Alloc    rdx  |    |I15a|I17a|    |    |    |    |    |    |
[000018]  85.#88  C18  Def    Alloc    r8   |    |I15a|I17a|    |    |    |    |C18a|    |
[000049]  86.#89  r8   Fixd   Keep     r8   |    |I15a|I17a|    |    |    |    |C18a|    |
          86.#90  C18  Use *  Keep     r8   |    |I15a|I17a|    |    |    |    |C18i|    |
          87.#91  r8   Fixd   Keep     r8   |    |I15a|I17a|    |    |    |    |    |    |
          87.#92  I19  Def    Alloc    r8   |    |I15a|I17a|    |    |    |    |I19a|    |
[000019]  92.#93  rcx  Fixd   Keep     rcx  |    |I15a|I17a|    |    |    |    |I19a|    |
          92.#94  I15  Use *  Keep     rcx  |    |I15i|I17a|    |    |    |    |I19a|    |
          92.#95  rdx  Fixd   Keep     rdx  |    |    |I17a|    |    |    |    |I19a|    |
          92.#96  I17  Use *  Keep     rdx  |    |    |I17i|    |    |    |    |I19a|    |
          92.#97  r8   Fixd   Keep     r8   |    |    |    |    |    |    |    |I19a|    |
          92.#98  I19  Use *  Keep     r8   |    |    |    |    |    |    |    |I19i|    |
          93.#99  rax  Kill   Keep     rax  |    |    |    |    |    |    |    |    |    |
          93.#100 rcx  Kill   Keep     rcx  |    |    |    |    |    |    |    |    |    |
          93.#101 rdx  Kill   Keep     rdx  |    |    |    |    |    |    |    |    |    |
          93.#102 r8   Kill   Keep     r8   |    |    |    |    |    |    |    |    |    |
          93.#103 r9   Kill   Keep     r9   |    |    |    |    |    |    |    |    |    |
          93.#104 r10  Kill   Keep     r10  |    |    |    |    |    |    |    |    |    |
          93.#105 r11  Kill   Keep     r11  |    |    |    |    |    |    |    |    |    |
          93.#106 rax  Fixd   Keep     rax  |    |    |    |    |    |    |    |    |    |
          93.#107 I20  Def    Alloc    rax  |I20a|    |    |    |    |    |    |    |    |
[000020]  94.#108 I20  Use *  Keep     rax  |I20i|    |    |    |    |    |    |    |    |

Recording the maximum number of concurrent spills:

----------
LSRA Stats
----------
Register selection order: ABCDEFGHIJKLMNOPQ
Total Tracked Vars:  0
Total Reg Cand Vars: 0
Total number of Intervals: 20
Total number of RefPositions: 108
Total Number of spill temps created: 0
..........
BB05 [  100.00]: BEST_FIT = 2
..........
Total SpillCount : 0   Weighted: 0.000000
Total CopyReg : 0   Weighted: 0.000000
Total ResolutionMovs : 0   Weighted: 0.000000
Total SplitEdges : 0   Weighted: 0.000000
..........
Total BEST_FIT [#11] : 2   Weighted: 200.000000

TUPLE STYLE DUMP WITH REGISTER ASSIGNMENTS
Incoming Parameters: 
BB01 [???..???), preds={} succs={BB02}
=====
  N002.                    NOP      

BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}
=====
  N006.                    CNS_INT(h) 0x7ffd10611d48 global ptr
  N008.                    IND      
  N010.                    CNS_INT   0
  N012.                    CMP      
  N014.                    JCC       cond=UEQ

BB03 [???..???), preds={BB02} succs={BB04}
=====
  N018.                    CALL help

BB04 [???..???), preds={BB02,BB03} succs={BB05}
=====

BB05 [000..023) (return), preds={BB04} succs={}
=====
  N024.                    IL_OFFSET INLRT @ 0x000[E-]
  N026.                    NO_OP    
  N028.                    IL_OFFSET INLRT @ 0x001[E-]
  N030. rcx             =  CNS_INT(h)  'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

  N032.                    V01 MEM; rcx
  N034.                    IL_OFFSET INLRT @ 0x007[E-]
  N036. rcx             =  CNS_INT(h) 0x7ffd107d1a48 class
  N038. rcx             =  PUTARG_REG; rcx
  N040. rdx             =  CNS_INT   3
  N042. rdx             =  PUTARG_REG; rdx
  N044. rax             =  CALL help; rcx,rdx
  N046.                    V04 MEM; rax
  N048.                    IL_OFFSET INLRT @ 0x00D[--]
  N050. rcx             =  CNS_INT(h) 0x7ffd107d1db0 field
  N052. rcx             =  PUTARG_REG; rcx
  N054. rax             =  CALL help; rcx
  N056.                    V05 MEM; rax
  N058. rcx             =  V04 MEM
  N060. rcx             =  PUTARG_REG; rcx
  N062. rdx             =  V05 MEM
  N064. rdx             =  PUTARG_REG; rdx
  N066.                    CALL     ; rcx,rdx
  N068.                    IL_OFFSET INLRT @ 0x018[--]
  N070. rcx             =  V04 MEM
  N072.                    V02 MEM; rcx
  N074.                    IL_OFFSET INLRT @ 0x019[E-]
  N076. rcx             =  V01 MEM
  N078. rcx             =  PUTARG_REG; rcx
  N080. rdx             =  V02 MEM
  N082. rdx             =  PUTARG_REG; rdx
  N084. r8              =  CNS_INT   1
  N086. r8              =  PUTARG_REG; r8
  N088.                    CNS_INT(h) 0x7ffd10624cd8 ftn
  N090.                    IND      
  N092. rax             =  CALL     ; rcx,rdx,r8
  N094.                    V06 MEM; rax
  N096.                    IL_OFFSET INLRT @ 0x021[--]
  N098.                    NOP      
  N100.                    IL_OFFSET INLRT @ 0x022[E-]
  N102.                    RETURN   




*************** Finishing PHASE Linear scan register alloc
Trees after Linear scan register alloc

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall LIR 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal LIR 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal LIR 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall LIR 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

------------ BB01 [???..???), preds={} succs={BB02}
N002 (  0,  0) [000000] -----------                            NOP       void   REG NA

------------ BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04}
N006 (  3, 10) [000024] Hc---------                   t24 =    CNS_INT(h) long   0x7ffd10611d48 global ptr REG NA
                                                            /--*  t24    long   
N008 (  5, 12) [000025] nc--G------                   t25 = *  IND       int    REG NA
N010 (  1,  1) [000026] -c---------                   t26 =    CNS_INT   int    0 REG NA
                                                            /--*  t25    int    
                                                            +--*  t26    int    
N012 (  7, 14) [000027] ----G--N---                         *  CMP       void   REG NA
N014 (  9, 16) [000033] ----G------                            JCC       void   cond=UEQ REG NA

------------ BB03 [???..???), preds={BB02} succs={BB04}
N018 ( 14,  5) [000028] --C-G-?----                            CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE REG NA

------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}

------------ BB05 [000..023) (return), preds={BB04} succs={}
N024 (???,???) [000034] -----------                            IL_OFFSET void   INLRT @ 0x000[E-] REG NA
N026 (  1,  1) [000001] -----------                            NO_OP     void   REG NA
N028 (???,???) [000035] -----------                            IL_OFFSET void   INLRT @ 0x001[E-] REG NA
N030 (  3, 10) [000032] H----------                   t32 =    CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '
 REG rcx
                                                            /--*  t32    ref    
N032 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0          NA REG NA
N034 (???,???) [000036] -----------                            IL_OFFSET void   INLRT @ 0x007[E-] REG NA
N036 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class REG rcx
                                                            /--*  t5     long   
N038 (???,???) [000042] -----------                   t42 = *  PUTARG_REG long   REG rcx
N040 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3 REG rdx
                                                            /--*  t4     long   
N042 (???,???) [000043] -----------                   t43 = *  PUTARG_REG long   REG rdx
                                                            /--*  t42    long   arg0 in rcx
                                                            +--*  t43    long   arg1 in rdx
N044 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC REG rax
                                                            /--*  t6     ref    
N046 ( 22, 21) [000007] DA-XG------                         *  STORE_LCL_VAR ref    V04 tmp1          NA REG NA
N048 (???,???) [000037] -----------                            IL_OFFSET void   INLRT @ 0x00D[--] REG NA
N050 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field REG rcx
                                                            /--*  t10    long   
N052 (???,???) [000044] -----------                   t44 = *  PUTARG_REG long   REG rcx
                                                            /--*  t44    long   arg0 in rcx
N054 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help ref    CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD REG rax
                                                            /--*  t11    ref    
N056 ( 27, 23) [000013] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2          NA REG NA
N058 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   ref    V04 tmp1          rcx REG rcx
                                                            /--*  t9     ref    
N060 (???,???) [000045] -----------                   t45 = *  PUTARG_REG ref    REG rcx
N062 (  3,  4) [000014] -----------                   t14 =    LCL_FLD   ref    V05 tmp2         [+0] rdx REG rdx
                                                            /--*  t14    ref    
N064 (???,???) [000046] -----------                   t46 = *  PUTARG_REG ref    REG rdx
                                                            /--*  t45    ref    arg0 in rcx
                                                            +--*  t46    ref    arg1 in rdx
N066 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle) REG NA
N068 (???,???) [000038] -----------                            IL_OFFSET void   INLRT @ 0x018[--] REG NA
N070 (  3,  2) [000008] -----------                    t8 =    LCL_VAR   ref    V04 tmp1          rcx REG rcx
                                                            /--*  t8     ref    
N072 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1          NA REG NA
N074 (???,???) [000039] -----------                            IL_OFFSET void   INLRT @ 0x019[E-] REG NA
N076 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0          rcx REG rcx
                                                            /--*  t16    ref    
N078 (???,???) [000047] -----------                   t47 = *  PUTARG_REG ref    REG rcx
N080 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1          rdx REG rdx
                                                            /--*  t17    ref    
N082 (???,???) [000048] -----------                   t48 = *  PUTARG_REG ref    REG rdx
N084 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1 REG r8
                                                            /--*  t18    int    
N086 (???,???) [000049] -----------                   t49 = *  PUTARG_REG int    REG r8
N088 (  3, 10) [000050] Hc---------                   t50 =    CNS_INT(h) long   0x7ffd10624cd8 ftn REG NA
                                                            /--*  t50    long   
N090 (  5, 12) [000051] nc--G------                   t51 = *  IND       long   REG NA
                                                            /--*  t47    ref    arg0 in rcx
                                                            +--*  t48    ref    arg1 in rdx
                                                            +--*  t49    int    arg2 in r8
                                                            +--*  t51    long   control expr
N092 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[] REG rax
                                                            /--*  t19    ref    
N094 ( 25, 16) [000020] DA-XG------                         *  STORE_LCL_VAR ref    V06 tmp3          NA REG NA
N096 (???,???) [000040] -----------                            IL_OFFSET void   INLRT @ 0x021[--] REG NA
N098 (  0,  0) [000022] -----------                            NOP       void   REG NA
N100 (???,???) [000041] -----------                            IL_OFFSET void   INLRT @ 0x022[E-] REG NA
N102 (  0,  0) [000023] -----------                            RETURN    void   REG NA

-------------------------------------------------------------------------------------------------------------------
*************** In fgDebugCheckBBlist
*************** In fgDebugCheckLoopTable: loop table not valid

*************** Starting PHASE Place 'align' instructions

*************** Finishing PHASE Place 'align' instructions [no changes]
*************** In genGenerateCode()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal hascall LIR 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal LIR 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal LIR 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal hascall LIR 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------

*************** Starting PHASE Generate code
*************** In fgDebugCheckBBlist
Finalizing stack frame
must init V01 because it has a GC ref
must init V02 because it has a GC ref
must init V04 because it has a GC ref
must init V05 because it has a GC ref
must init V06 because it has a GC ref
Modified regs: [rax rcx rdx r8-r11]
Callee-saved registers pushed: 0 []
*************** In lvaAssignFrameOffsets(FINAL_FRAME_LAYOUT)
Assign V01 loc0, size=8, stkOffs=-0x18
Assign V02 loc1, size=8, stkOffs=-0x20
Assign V04 tmp1, size=8, stkOffs=-0x28
Assign V05 tmp2, size=8, stkOffs=-0x30
Assign V06 tmp3, size=8, stkOffs=-0x38
Assign V03 OutArgs, size=32, stkOffs=-0x58
--- delta bump 8 for RA
--- delta bump 8 for FP
--- delta bump 0 for FP frame
--- virtual stack offset to actual stack offset delta is 16
-- V00 was 0, now 16
-- V01 was -24, now -8
-- V02 was -32, now -16
-- V03 was -88, now -72
-- V04 was -40, now -24
-- V05 was -48, now -32
-- V06 was -56, now -40
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  1,  1   )     ref  ->  [rbp+10H]   do-not-enreg[] class-hnd <System.String[]>
;  V01 loc0         [V01    ] (  1,  1   )     ref  ->  [rbp-08H]   do-not-enreg[] must-init class-hnd exact <System.String>
;  V02 loc1         [V02    ] (  1,  1   )     ref  ->  [rbp-10H]   do-not-enreg[] must-init class-hnd exact <ushort[]>
;  V03 OutArgs      [V03    ] (  1,  1   )  struct (32) [rsp+00H]   do-not-enreg[XS] addr-exposed "OutgoingArgSpace"
;  V04 tmp1         [V04    ] (  1,  1   )     ref  ->  [rbp-18H]   do-not-enreg[] must-init class-hnd exact "impSpillStackEnsure" <ushort[]>
;  V05 tmp2         [V05    ] (  1,  1   )  struct ( 8) [rbp-20H]   do-not-enreg[S] must-init "spilled call-like call argument" <System.RuntimeFieldHandle>
;  V06 tmp3         [V06    ] (  1,  1   )     ref  ->  [rbp-28H]   do-not-enreg[] must-init class-hnd exact "impSpillStackEnsure" <System.String[]>
;
; Lcl frame size = 80
Created:
      G_M45957_IG02:        ; offs=000000H, size=0000H, bbWeight=1, gcrefRegs=0000 {}
Mark labels for codegen
  BB01 : first block
  BB04 : branch target
*************** After genMarkLabelsForCodegen()

-----------------------------------------------------------------------------------------------------------------------------------------
BBnum BBid ref try hnd preds           weight    lp [IL range]     [jump]      [EH region]         [flags]
-----------------------------------------------------------------------------------------------------------------------------------------
BB01 [0000]  1                             1       [???..???)                                     i internal label hascall LIR 
BB02 [0003]  1       BB01                  1       [???..???)-> BB04 ( cond )                     internal LIR 
BB03 [0004]  1       BB02                  0.50    [???..???)                                     internal LIR 
BB04 [0002]  2       BB02,BB03             1       [???..???)                                     i internal label hascall LIR 
BB05 [0001]  1       BB04                  1       [000..023)        (return)                     i hascall gcsafe LIR 
-----------------------------------------------------------------------------------------------------------------------------------------
Setting stack level from -572662307 to 0

=============== Generating BB01 [???..???), preds={} succs={BB02} flags=0x00000001.00020031: i internal label hascall LIR 
BB01 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 0000 {}
							GC regs: (unchanged) 0000 {}
							Byref regs: (unchanged) 0000 {}

      L_M45957_BB01:
Label: G_M45957_IG02, GCvars=0000000000000000 {}, gcrefRegs=0000 {}, byrefRegs=0000 {}

Scope info: begin block BB01, IL range [???..???)
Scope info: ignoring block beginning
Generating: N002 (  0,  0) [000000] -----------                            NOP       void   REG NA
Scope info: ignoring block end

Variable Live Range History Dump for BB01
..None..

=============== Generating BB02 [???..???) -> BB04 (cond), preds={BB01} succs={BB03,BB04} flags=0x00000000.00000021: internal LIR 
BB02 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 0000 {}
							GC regs: (unchanged) 0000 {}
							Byref regs: (unchanged) 0000 {}

      L_M45957_BB02:

Scope info: begin block BB02, IL range [???..???)
Scope info: ignoring block beginning
Added IP mapping: NO_MAP (G_M45957_IG02,ins#0,ofs#0) label
Generating: N006 (  3, 10) [000024] Hc---------                   t24 =    CNS_INT(h) long   0x7ffd10611d48 global ptr REG NA
                                                                        /--*  t24    long   
Generating: N008 (  5, 12) [000025] nc--G------                   t25 = *  IND       int    REG NA
Generating: N010 (  1,  1) [000026] -c---------                   t26 =    CNS_INT   int    0 REG NA
                                                                        /--*  t25    int    
                                                                        +--*  t26    int    
Generating: N012 (  7, 14) [000027] ----G--N---                         *  CMP       void   REG NA
Mapped BB02 to G_M45957_IG02
IN0001:        cmp      dword ptr [(reloc 0x7ffd10611d48)], 0
Generating: N014 (  9, 16) [000033] ----G------                            JCC       void   cond=UEQ REG NA
IN0002:        je       L_M45957_BB04
Scope info: ignoring block end

Variable Live Range History Dump for BB02
..None..

=============== Generating BB03 [???..???), preds={BB02} succs={BB04} flags=0x00000000.00000021: internal LIR 
BB03 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 0000 {}
							GC regs: (unchanged) 0000 {}
							Byref regs: (unchanged) 0000 {}

      L_M45957_BB03:
Adding label due to BB weight difference: BBJ_COND BB02 with weight 100 different from BB03 with weight 50
Saved:
      G_M45957_IG02:        ; offs=000000H, size=000DH, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB02 [0003], byref
Created:
      G_M45957_IG03:        ; offs=00000DH, size=0000H, bbWeight=0.50, gcrefRegs=0000 {}
Label: G_M45957_IG03, GCvars=0000000000000000 {}, gcrefRegs=0000 {}, byrefRegs=0000 {}

Scope info: begin block BB03, IL range [???..???)
Scope info: ignoring block beginning
genIPmappingAdd: ignoring duplicate IL offset 0xffffffff
Generating: N018 ( 14,  5) [000028] --C-G-?----                            CALL help void   CORINFO_HELP_DBG_IS_JUST_MY_CODE REG NA
							Call: GCvars=0000000000000000 {}, gcrefRegs=0000 {}, byrefRegs=0000 {}
Mapped BB03 to G_M45957_IG03
IN0003:        call     CORINFO_HELP_DBG_IS_JUST_MY_CODE
Scope info: ignoring block end

Variable Live Range History Dump for BB03
..None..

=============== Generating BB04 [???..???), preds={BB02,BB03} succs={BB05} flags=0x00000001.00020031: i internal label hascall LIR 
BB04 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 0000 {}
							GC regs: (unchanged) 0000 {}
							Byref regs: (unchanged) 0000 {}

      L_M45957_BB04:
Saved:
      G_M45957_IG03:        ; offs=00000DH, size=0005H, bbWeight=0.50, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB03 [0004], byref
Created:
      G_M45957_IG04:        ; offs=000012H, size=0000H, bbWeight=1, gcrefRegs=0000 {}
Label: G_M45957_IG04, GCvars=0000000000000000 {}, gcrefRegs=0000 {}, byrefRegs=0000 {}

Scope info: begin block BB04, IL range [???..???)
Scope info: ignoring block beginning
genIPmappingAdd: ignoring duplicate IL offset 0xffffffff
Scope info: ignoring block end

Variable Live Range History Dump for BB04
..None..

=============== Generating BB05 [000..023) (return), preds={BB04} succs={} flags=0x00000001.00200011: i hascall gcsafe LIR 
BB05 IN (0)={} + ByrefExposed + GcHeap
     OUT(0)={} + ByrefExposed + GcHeap

Liveness not changing: 0000000000000000 {}
							Live regs: (unchanged) 0000 {}
							GC regs: (unchanged) 0000 {}
							Byref regs: (unchanged) 0000 {}

      L_M45957_BB05:

Scope info: begin block BB05, IL range [000..023)
Scope info: opening scope, LVnum=0 [000..023)
New debug range: first
Scope info: opening scope, LVnum=1 [000..023)
New debug range: first
Scope info: opening scope, LVnum=2 [000..023)
New debug range: first
Added IP mapping: 0x0000 STACK_EMPTY (G_M45957_IG04,ins#0,ofs#0) label
Generating: N024 (???,???) [000034] -----------                            IL_OFFSET void   INLRT @ 0x000[E-] REG NA
Generating: N026 (  1,  1) [000001] -----------                            NO_OP     void   REG NA
Mapped BB05 to G_M45957_IG04
IN0004:        nop      
Added IP mapping: 0x0001 STACK_EMPTY (G_M45957_IG04,ins#1,ofs#1)
Generating: N028 (???,???) [000035] -----------                            IL_OFFSET void   INLRT @ 0x001[E-] REG NA
Generating: N030 (  3, 10) [000032] H----------                   t32 =    CNS_INT(h) ref     'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '
 REG rcx
IN0005:        mov      rcx, 0x1E380201760      ; 'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

							GC regs: 0000 {} => 0002 {rcx}
                                                                        /--*  t32    ref    
Generating: N032 (  7, 13) [000003] DA---------                         *  STORE_LCL_VAR ref    V01 loc0          NA REG NA
							GC regs: 0002 {rcx} => 0000 {}
IN0006:        mov      gword ptr [V01 rbp-08H], rcx
Added IP mapping: 0x0007 STACK_EMPTY (G_M45957_IG04,ins#3,ofs#15)
Generating: N034 (???,???) [000036] -----------                            IL_OFFSET void   INLRT @ 0x007[E-] REG NA
Generating: N036 (  3, 10) [000005] H----------                    t5 =    CNS_INT(h) long   0x7ffd107d1a48 class REG rcx
IN0007:        mov      rcx, 0x7FFD107D1A48      ; ushort[]
                                                                        /--*  t5     long   
Generating: N038 (???,???) [000042] -----------                   t42 = *  PUTARG_REG long   REG rcx
Generating: N040 (  1,  1) [000004] -----------                    t4 =    CNS_INT   long   3 REG rdx
IN0008:        mov      edx, 3
                                                                        /--*  t4     long   
Generating: N042 (???,???) [000043] -----------                   t43 = *  PUTARG_REG long   REG rdx
                                                                        /--*  t42    long   arg0 in rcx
                                                                        +--*  t43    long   arg1 in rdx
Generating: N044 ( 18, 18) [000006] --CXG------                    t6 = *  CALL help ref    CORINFO_HELP_NEWARR_1_VC REG rax
							Call: GCvars=0000000000000000 {}, gcrefRegs=0000 {}, byrefRegs=0000 {}
IN0009:        call     CORINFO_HELP_NEWARR_1_VC
							GC regs: 0000 {} => 0001 {rax}
                                                                        /--*  t6     ref    
Generating: N046 ( 22, 21) [000007] DA-XG------                         *  STORE_LCL_VAR ref    V04 tmp1          NA REG NA
							GC regs: 0001 {rax} => 0000 {}
IN000a:        mov      gword ptr [V04 rbp-18H], rax
Added IP mapping: 0x000D (G_M45957_IG04,ins#7,ofs#39)
Generating: N048 (???,???) [000037] -----------                            IL_OFFSET void   INLRT @ 0x00D[--] REG NA
Generating: N050 (  3, 10) [000010] H----------                   t10 =    CNS_INT(h) long   0x7ffd107d1db0 field REG rcx
IN000b:        mov      rcx, 0x7FFD107D1DB0      ; <PrivateImplementationDetails>:8EF6341A03FE4690DA03E4B9770B67F1FB07C68BBE1CE709341225060715D4A5
                                                                        /--*  t10    long   
Generating: N052 (???,???) [000044] -----------                   t44 = *  PUTARG_REG long   REG rcx
                                                                        /--*  t44    long   arg0 in rcx
Generating: N054 ( 17, 16) [000011] --CXG------                   t11 = *  CALL help ref    CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD REG rax
							Call: GCvars=0000000000000000 {}, gcrefRegs=0000 {}, byrefRegs=0000 {}
IN000c:        call     CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
							GC regs: 0000 {} => 0001 {rax}
                                                                        /--*  t11    ref    
Generating: N056 ( 27, 23) [000013] DA-XG------                         *  STORE_LCL_VAR struct<System.RuntimeFieldHandle, 8> V05 tmp2          NA REG NA
							GC regs: 0001 {rax} => 0000 {}
IN000d:        mov      gword ptr [V05 rbp-20H], rax
Generating: N058 (  3,  2) [000009] -----------                    t9 =    LCL_VAR   ref    V04 tmp1          rcx REG rcx
IN000e:        mov      rcx, gword ptr [V04 rbp-18H]
							GC regs: 0000 {} => 0002 {rcx}
                                                                        /--*  t9     ref    
Generating: N060 (???,???) [000045] -----------                   t45 = *  PUTARG_REG ref    REG rcx
							GC regs: 0002 {rcx} => 0000 {}
							GC regs: 0000 {} => 0002 {rcx}
Generating: N062 (  3,  4) [000014] -----------                   t14 =    LCL_FLD   ref    V05 tmp2         [+0] rdx REG rdx
IN000f:        mov      rdx, gword ptr [V05 rbp-20H]
							GC regs: 0002 {rcx} => 0006 {rcx rdx}
                                                                        /--*  t14    ref    
Generating: N064 (???,???) [000046] -----------                   t46 = *  PUTARG_REG ref    REG rdx
							GC regs: 0006 {rcx rdx} => 0002 {rcx}
							GC regs: 0002 {rcx} => 0006 {rcx rdx}
                                                                        /--*  t45    ref    arg0 in rcx
                                                                        +--*  t46    ref    arg1 in rdx
Generating: N066 ( 20, 13) [000012] --CXG------                         *  CALL      void   System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle) REG NA
							GC regs: 0006 {rcx rdx} => 0004 {rdx}
							GC regs: 0004 {rdx} => 0000 {}
							Call: GCvars=0000000000000000 {}, gcrefRegs=0000 {}, byrefRegs=0000 {}
Added IP mapping: 0x0013 CALL_INSTRUCTION (G_M45957_IG04,ins#12,ofs#66)
IN0010:        call     System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
Added IP mapping: 0x0018 (G_M45957_IG04,ins#13,ofs#71)
Generating: N068 (???,???) [000038] -----------                            IL_OFFSET void   INLRT @ 0x018[--] REG NA
Generating: N070 (  3,  2) [000008] -----------                    t8 =    LCL_VAR   ref    V04 tmp1          rcx REG rcx
IN0011:        mov      rcx, gword ptr [V04 rbp-18H]
							GC regs: 0000 {} => 0002 {rcx}
                                                                        /--*  t8     ref    
Generating: N072 (  7,  5) [000015] DA---------                         *  STORE_LCL_VAR ref    V02 loc1          NA REG NA
							GC regs: 0002 {rcx} => 0000 {}
IN0012:        mov      gword ptr [V02 rbp-10H], rcx
Added IP mapping: 0x0019 STACK_EMPTY (G_M45957_IG04,ins#15,ofs#79)
Generating: N074 (???,???) [000039] -----------                            IL_OFFSET void   INLRT @ 0x019[E-] REG NA
Generating: N076 (  3,  2) [000016] -----------                   t16 =    LCL_VAR   ref    V01 loc0          rcx REG rcx
IN0013:        mov      rcx, gword ptr [V01 rbp-08H]
							GC regs: 0000 {} => 0002 {rcx}
                                                                        /--*  t16    ref    
Generating: N078 (???,???) [000047] -----------                   t47 = *  PUTARG_REG ref    REG rcx
							GC regs: 0002 {rcx} => 0000 {}
							GC regs: 0000 {} => 0002 {rcx}
Generating: N080 (  3,  2) [000017] -----------                   t17 =    LCL_VAR   ref    V02 loc1          rdx REG rdx
IN0014:        mov      rdx, gword ptr [V02 rbp-10H]
							GC regs: 0002 {rcx} => 0006 {rcx rdx}
                                                                        /--*  t17    ref    
Generating: N082 (???,???) [000048] -----------                   t48 = *  PUTARG_REG ref    REG rdx
							GC regs: 0006 {rcx rdx} => 0002 {rcx}
							GC regs: 0002 {rcx} => 0006 {rcx rdx}
Generating: N084 (  1,  1) [000018] -----------                   t18 =    CNS_INT   int    1 REG r8
IN0015:        mov      r8d, 1
                                                                        /--*  t18    int    
Generating: N086 (???,???) [000049] -----------                   t49 = *  PUTARG_REG int    REG r8
Generating: N088 (  3, 10) [000050] Hc---------                   t50 =    CNS_INT(h) long   0x7ffd10624cd8 ftn REG NA
                                                                        /--*  t50    long   
Generating: N090 (  5, 12) [000051] nc--G------                   t51 = *  IND       long   REG NA
                                                                        /--*  t47    ref    arg0 in rcx
                                                                        +--*  t48    ref    arg1 in rdx
                                                                        +--*  t49    int    arg2 in r8
                                                                        +--*  t51    long   control expr
Generating: N092 ( 21, 13) [000019] --CXG------                   t19 = *  CALL      ref    System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[] REG rax
							GC regs: 0006 {rcx rdx} => 0004 {rdx}
							GC regs: 0004 {rdx} => 0000 {}
							Call: GCvars=0000000000000000 {}, gcrefRegs=0000 {}, byrefRegs=0000 {}
Added IP mapping: 0x001C CALL_INSTRUCTION (G_M45957_IG04,ins#18,ofs#93)
IN0016:        call     [System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]]
							GC regs: 0000 {} => 0001 {rax}
                                                                        /--*  t19    ref    
Generating: N094 ( 25, 16) [000020] DA-XG------                         *  STORE_LCL_VAR ref    V06 tmp3          NA REG NA
							GC regs: 0001 {rax} => 0000 {}
IN0017:        mov      gword ptr [V06 rbp-28H], rax
Added IP mapping: 0x0021 (G_M45957_IG04,ins#20,ofs#103)
Generating: N096 (???,???) [000040] -----------                            IL_OFFSET void   INLRT @ 0x021[--] REG NA
Generating: N098 (  0,  0) [000022] -----------                            NOP       void   REG NA
IN0018:        nop      
Added IP mapping: 0x0022 STACK_EMPTY (G_M45957_IG04,ins#21,ofs#104)
Generating: N100 (???,???) [000041] -----------                            IL_OFFSET void   INLRT @ 0x022[E-] REG NA
Generating: N102 (  0,  0) [000023] -----------                            RETURN    void   REG NA
IN0019:        nop      
Closing debug range.
Closing debug range.
Closing debug range.
Added IP mapping: EPILOG (G_M45957_IG04,ins#22,ofs#105) label
Reserving epilog IG for block BB05
Saved:
      G_M45957_IG04:        ; offs=000012H, size=0069H, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB05 [0001], byref
Created:
      G_M45957_IG05:        ; offs=00007BH, size=0000H, bbWeight=1, gcrefRegs=0000 {}
*************** After placeholder IG creation
G_M45957_IG01:        ; func=00, offs=000000H, size=0000H, bbWeight=1, gcrefRegs=0000 {} <-- Prolog IG
G_M45957_IG02:        ; offs=000000H, size=000DH, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB02 [0003], byref
G_M45957_IG03:        ; offs=00000DH, size=0005H, bbWeight=0.50, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB03 [0004], byref
G_M45957_IG04:        ; offs=000012H, size=0069H, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB05 [0001], byref
G_M45957_IG05:        ; epilog placeholder, next placeholder=<END>, BB05 [0001], epilog, extend <-- First placeholder <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=0000 {}, PrevByrefRegs=0000 {}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=0000 {}, InitByrefRegs=0000 {}

Variable Live Range History Dump for BB05
V00 arg0: rbp[16] (1 slot) [(G_M45957_IG04,ins#0,ofs#0), (G_M45957_IG04,ins#22,ofs#105)]
V01 loc0: rbp[-8] (1 slot) [(G_M45957_IG04,ins#0,ofs#0), (G_M45957_IG04,ins#22,ofs#105)]
V02 loc1: rbp[-16] (1 slot) [(G_M45957_IG04,ins#0,ofs#0), (G_M45957_IG04,ins#22,ofs#105)]
Liveness not changing: 0000000000000000 {}

# compCycleEstimate =    132, compSizeEstimate =   113 System.Runtime.Intrinsics.X86.Program:Main(System.String[])
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  1,  1   )     ref  ->  [rbp+10H]   do-not-enreg[] class-hnd <System.String[]>
;  V01 loc0         [V01    ] (  1,  1   )     ref  ->  [rbp-08H]   do-not-enreg[] must-init class-hnd exact <System.String>
;  V02 loc1         [V02    ] (  1,  1   )     ref  ->  [rbp-10H]   do-not-enreg[] must-init class-hnd exact <ushort[]>
;  V03 OutArgs      [V03    ] (  1,  1   )  struct (32) [rsp+00H]   do-not-enreg[XS] addr-exposed "OutgoingArgSpace"
;  V04 tmp1         [V04    ] (  1,  1   )     ref  ->  [rbp-18H]   do-not-enreg[] must-init class-hnd exact "impSpillStackEnsure" <ushort[]>
;  V05 tmp2         [V05    ] (  1,  1   )  struct ( 8) [rbp-20H]   do-not-enreg[S] must-init "spilled call-like call argument" <System.RuntimeFieldHandle>
;  V06 tmp3         [V06    ] (  1,  1   )     ref  ->  [rbp-28H]   do-not-enreg[] must-init class-hnd exact "impSpillStackEnsure" <System.String[]>
;
; Lcl frame size = 80
*************** Before prolog / epilog generation
G_M45957_IG01:        ; func=00, offs=000000H, size=0000H, bbWeight=1, gcrefRegs=0000 {} <-- Prolog IG
G_M45957_IG02:        ; offs=000000H, size=000DH, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB02 [0003], byref
G_M45957_IG03:        ; offs=00000DH, size=0005H, bbWeight=0.50, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB03 [0004], byref
G_M45957_IG04:        ; offs=000012H, size=0069H, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB05 [0001], byref
G_M45957_IG05:        ; epilog placeholder, next placeholder=<END>, BB05 [0001], epilog, extend <-- First placeholder <-- Last placeholder
                      ;   PrevGCVars=0000000000000000 {}, PrevGCrefRegs=0000 {}, PrevByrefRegs=0000 {}
                      ;   InitGCVars=0000000000000000 {}, InitGCrefRegs=0000 {}, InitByrefRegs=0000 {}
*************** In genFnProlog()
Added IP mapping to front: PROLOG (G_M45957_IG01,ins#0,ofs#0) label

__prolog:
New debug range: first
Found 10 lvMustInit int-sized stack slots, frame offsets 40 through 0
IN001a:        push     rbp
IN001b:        sub      rsp, 80
IN001c:        lea      rbp, [rsp+50H]
IN001d:        xor      rax, rax
IN001e:        mov      qword ptr [rbp-28H], rax
IN001f:        vxorps   xmm4, xmm4, xmm4
IN0020:        vmovdqa32 xmmword ptr [rbp-20H], xmm4
IN0021:        vmovdqa32 xmmword ptr [rbp-10H], xmm4
*************** In genFnPrologCalleeRegArgs() for int regs
IN0022:        mov      gword ptr [V00 rbp+10H], rcx
*************** In genEnregisterIncomingStackArgs()
Closing debug range.

Saved:
      G_M45957_IG01:        ; offs=000000H, size=0028H, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, byref, nogc
*************** In genFnEpilog()

__epilog:
gcVarPtrSetCur=0000000000000000 {}, gcRegGCrefSetCur=0000 {}, gcRegByrefSetCur=0000 {}
IN0023:        add      rsp, 80
IN0024:        pop      rbp
IN0025:        ret      
Saved:
      G_M45957_IG05:        ; offs=00007BH, size=0006H, bbWeight=1, epilog, nogc, extend
0 prologs, 1 epilogs, 0 funclet prologs, 0 funclet epilogs
*************** After prolog / epilog generation
G_M45957_IG01:        ; func=00, offs=000000H, size=0028H, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, byref, nogc <-- Prolog IG
G_M45957_IG02:        ; offs=000028H, size=000DH, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB02 [0003], byref
G_M45957_IG03:        ; offs=000035H, size=0005H, bbWeight=0.50, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB03 [0004], byref
G_M45957_IG04:        ; offs=00003AH, size=0069H, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB05 [0001], byref
G_M45957_IG05:        ; offs=0000A3H, size=0006H, bbWeight=1, epilog, nogc, extend
*************** In emitJumpDistBind()
Emitter Jump List:
IG02 IN0002  je[6] -> IG04
  total jump count: 1
Binding: IN0002: 000000 je       L_M45957_BB04
Binding L_M45957_BB04 to G_M45957_IG04
Estimate of fwd jump [800D8CFC/002]: 002F -> 003A = 0009
Shrinking jump [800D8CFC/002]
Adjusted offset of BB03 from 0035 to 0031
Adjusted offset of BB04 from 003A to 0036
Adjusted offset of BB05 from 00A3 to 009F
Total shrinkage =   4, min extra jump size = 4294967295

*************** Finishing PHASE Generate code

*************** Starting PHASE Emit code

Hot  code size = 0xA5 bytes
Cold code size = 0x0 bytes
reserveUnwindInfo(isFunclet=false, isColdCode=false, unwindSize=0x8)
*************** In emitEndCodeGen()
Converting emitMaxStackDepth from bytes (0) to elements (0)

***************************************************************************
Instructions as they come out of the scheduler


G_M45957_IG01:        ; offs=000000H, size=0028H, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, byref, nogc <-- Prolog IG
IN001a: 000000 push     rbp
IN001b: 000001 sub      rsp, 80
IN001c: 000005 lea      rbp, [rsp+50H]
IN001d: 00000A xor      eax, eax
IN001e: 00000C mov      qword ptr [rbp-28H], rax
IN001f: 000010 vxorps   xmm4, xmm4, xmm4
IN0020: 000016 vmovdqa32 xmmword ptr [rbp-20H], xmm4
IN0021: 00001D vmovdqa32 xmmword ptr [rbp-10H], xmm4
IN0022: 000024 mov      gword ptr [rbp+10H], rcx
						;; size=40 bbWeight=1 PerfScore 8.33
G_M45957_IG02:        ; offs=000028H, size=0009H, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB02 [0003], byref, isz
recordRelocation: 00007FFD10415C4A (rw: 000001E380012A32) => 00007FFD10611D48, type 16 (IMAGE_REL_BASED_DISP32), delta -1
IN0001: 000028 cmp      dword ptr [(reloc 0x7ffd10611d48)], 0
IN0002: 00002F je       SHORT G_M45957_IG04
						;; size=9 bbWeight=1 PerfScore 4.00
G_M45957_IG03:        ; offs=000031H, size=0005H, bbWeight=0.50, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB03 [0004], byref
recordRelocation: 00007FFD10415C52 (rw: 000001E380012A3A) => 00007FFD6EC56D30, type 16 (IMAGE_REL_BASED_REL32), delta 0
IN0003: 000031 call     CORINFO_HELP_DBG_IS_JUST_MY_CODE
                            ; gcr arg pop 0
						;; size=5 bbWeight=0.50 PerfScore 0.50
G_M45957_IG04:        ; offs=000036H, size=0069H, bbWeight=1, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB05 [0001], byref
IN0004: 000036 nop      
IN0005: 000037 mov      rcx, 0x1E380201760      ; 'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

                            ; gcrRegs +[rcx]
IN0006: 000041 mov      gword ptr [rbp-08H], rcx
IN0007: 000045 mov      rcx, 0x7FFD107D1A48      ; ushort[]
                            ; gcrRegs -[rcx]
IN0008: 00004F mov      edx, 3
recordRelocation: 00007FFD10415C75 (rw: 000001E380012A5D) => 00007FFD6F0C5AC0, type 16 (IMAGE_REL_BASED_REL32), delta 0
IN0009: 000054 call     CORINFO_HELP_NEWARR_1_VC
                            ; gcrRegs +[rax]
                            ; gcr arg pop 0
IN000a: 000059 mov      gword ptr [rbp-18H], rax
IN000b: 00005D mov      rcx, 0x7FFD107D1DB0      ; <PrivateImplementationDetails>:8EF6341A03FE4690DA03E4B9770B67F1FB07C68BBE1CE709341225060715D4A5
recordRelocation: 00007FFD10415C88 (rw: 000001E380012A70) => 00007FFD6EC64030, type 16 (IMAGE_REL_BASED_REL32), delta 0
IN000c: 000067 call     CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
                            ; gcr arg pop 0
IN000d: 00006C mov      gword ptr [rbp-20H], rax
IN000e: 000070 mov      rcx, gword ptr [rbp-18H]
                            ; gcrRegs +[rcx]
IN000f: 000074 mov      rdx, gword ptr [rbp-20H]
                            ; gcrRegs +[rdx]
recordRelocation: 00007FFD10415C99 (rw: 000001E380012A81) => 00007FFD6F2D2850, type 16 (IMAGE_REL_BASED_REL32), delta 0
IN0010: 000078 call     System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
                            ; gcrRegs -[rax rcx rdx]
                            ; gcr arg pop 0
IN0011: 00007D mov      rcx, gword ptr [rbp-18H]
                            ; gcrRegs +[rcx]
IN0012: 000081 mov      gword ptr [rbp-10H], rcx
IN0013: 000085 mov      rcx, gword ptr [rbp-08H]
IN0014: 000089 mov      rdx, gword ptr [rbp-10H]
                            ; gcrRegs +[rdx]
IN0015: 00008D mov      r8d, 1
recordRelocation: 00007FFD10415CB5 (rw: 000001E380012A9D) => 00007FFD10624CD8, type 16 (IMAGE_REL_BASED_DISP32), delta 0
IN0016: 000093 call     [System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]]
                            ; gcrRegs -[rcx rdx] +[rax]
                            ; gcr arg pop 0
IN0017: 000099 mov      gword ptr [rbp-28H], rax
IN0018: 00009D nop      
IN0019: 00009E nop      
						;; size=105 bbWeight=1 PerfScore 18.00
G_M45957_IG05:        ; offs=00009FH, size=0006H, bbWeight=1, epilog, nogc, extend
IN0023: 00009F add      rsp, 80
IN0024: 0000A3 pop      rbp
IN0025: 0000A4 ret      
						;; size=6 bbWeight=1 PerfScore 1.75Allocated method code size =  165 , actual size =  165, unused size =    0

; Total bytes of code 165, prolog size 40, PerfScore 49.08, instruction count 37, allocated bytes for code 165 (MethodHash=1e684c7a) for method System.Runtime.Intrinsics.X86.Program:Main(System.String[]) (MinOpts)
; ============================================================

*************** After end code gen, before unwindEmit()
G_M45957_IG01:        ; func=00, offs=000000H, size=0028H, bbWeight=1, PerfScore 8.33, gcrefRegs=0000 {}, byrefRegs=0000 {}, byref, nogc <-- Prolog IG

IN001a: 000000 push     rbp
IN001b: 000001 sub      rsp, 80
IN001c: 000005 lea      rbp, [rsp+50H]
IN001d: 00000A xor      eax, eax
IN001e: 00000C mov      qword ptr [rbp-28H], rax
IN001f: 000010 vxorps   xmm4, xmm4, xmm4
IN0020: 000016 vmovdqa32 xmmword ptr [rbp-20H], xmm4
IN0021: 00001D vmovdqa32 xmmword ptr [rbp-10H], xmm4
IN0022: 000024 mov      gword ptr [V00 rbp+10H], rcx

G_M45957_IG02:        ; offs=000028H, size=0009H, bbWeight=1, PerfScore 4.00, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB02 [0003], byref, isz

IN0001: 000028 cmp      dword ptr [(reloc 0x7ffd10611d48)], 0
IN0002: 00002F je       SHORT G_M45957_IG04

G_M45957_IG03:        ; offs=000031H, size=0005H, bbWeight=0.50, PerfScore 0.50, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB03 [0004], byref

IN0003: 000031 call     CORINFO_HELP_DBG_IS_JUST_MY_CODE

G_M45957_IG04:        ; offs=000036H, size=0069H, bbWeight=1, PerfScore 18.00, gcrefRegs=0000 {}, byrefRegs=0000 {}, BB05 [0001], byref

IN0004: 000036 nop      
IN0005: 000037 mov      rcx, 0x1E380201760      ; 'ABCDEFGHIJKLMNOPQRSTUVWXYZ A B C D E F G H I J K L M N O P Q R '

IN0006: 000041 mov      gword ptr [V01 rbp-08H], rcx
IN0007: 000045 mov      rcx, 0x7FFD107D1A48      ; ushort[]
IN0008: 00004F mov      edx, 3
IN0009: 000054 call     CORINFO_HELP_NEWARR_1_VC
IN000a: 000059 mov      gword ptr [V04 rbp-18H], rax
IN000b: 00005D mov      rcx, 0x7FFD107D1DB0      ; <PrivateImplementationDetails>:8EF6341A03FE4690DA03E4B9770B67F1FB07C68BBE1CE709341225060715D4A5
IN000c: 000067 call     CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD
IN000d: 00006C mov      gword ptr [V05 rbp-20H], rax
IN000e: 000070 mov      rcx, gword ptr [V04 rbp-18H]
IN000f: 000074 mov      rdx, gword ptr [V05 rbp-20H]
IN0010: 000078 call     System.Runtime.CompilerServices.RuntimeHelpers:InitializeArray(System.Array,System.RuntimeFieldHandle)
IN0011: 00007D mov      rcx, gword ptr [V04 rbp-18H]
IN0012: 000081 mov      gword ptr [V02 rbp-10H], rcx
IN0013: 000085 mov      rcx, gword ptr [V01 rbp-08H]
IN0014: 000089 mov      rdx, gword ptr [V02 rbp-10H]
IN0015: 00008D mov      r8d, 1
IN0016: 000093 call     [System.Runtime.Intrinsics.X86.Program:Split(System.String,ushort[],int):System.String[]]
IN0017: 000099 mov      gword ptr [V06 rbp-28H], rax
IN0018: 00009D nop      
IN0019: 00009E nop      

G_M45957_IG05:        ; offs=00009FH, size=0006H, bbWeight=1, PerfScore 1.75, epilog, nogc, extend

IN0023: 00009F add      rsp, 80
IN0024: 0000A3 pop      rbp
IN0025: 0000A4 ret      


*************** Finishing PHASE Emit code

*************** Starting PHASE Emit GC+EH tables
Unwind Info:
  >> Start offset   : 0x000000 (not in unwind data)
  >>   End offset   : 0x0000a5 (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x05
  CountOfUnwindCodes: 2
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x05 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 9 * 8 + 8 = 80 = 0x50
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
allocUnwindInfo(pHotCode=0x00007FFD10415C20, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0xa5, unwindSize=0x8, pUnwindBlock=0x000001E3800D1108, funKind=0 (main function))
*************** In genIPmappingGen()
IP mapping count : 13
IL offs PROLOG : 0x00000000 ( STACK_EMPTY )
IL offs NO_MAP : 0x00000028 ( STACK_EMPTY )
IL offs 0x0000 : 0x00000036 ( STACK_EMPTY )
IL offs 0x0001 : 0x00000037 ( STACK_EMPTY )
IL offs 0x0007 : 0x00000045 ( STACK_EMPTY )
IL offs 0x000D : 0x0000005D
IL offs 0x0013 : 0x00000078 ( CALL_INSTRUCTION )
IL offs 0x0018 : 0x0000007D
IL offs 0x0019 : 0x00000085 ( STACK_EMPTY )
IL offs 0x001C : 0x00000093 ( CALL_INSTRUCTION )
IL offs 0x0021 : 0x0000009D
IL offs 0x0022 : 0x0000009E ( STACK_EMPTY )
IL offs EPILOG : 0x0000009F ( STACK_EMPTY )

*************** In genSetScopeInfo()
VarLocInfo count is 4
; Variable debug info: 4 live ranges, 3 vars for method System.Runtime.Intrinsics.X86.Program:Main(System.String[])
(V00 arg0) : From 00000000h to 00000028h, in rcx
(V00 arg0) : From 00000036h to 0000009Fh, in rbp[16] (1 slot)
(V01 loc0) : From 00000036h to 0000009Fh, in rbp[-8] (1 slot)
(V02 loc1) : From 00000036h to 0000009Fh, in rbp[-16] (1 slot)
*************** In gcInfoBlockHdrSave()
Set code length to 165.
Set ReturnKind to Scalar.
Set stack base register to rbp.
Set Outgoing stack arg area size to 32.
Stack slot id for offset 16 (0x10) (frame) (untracked) = 0.
Stack slot id for offset -8 (-0x8) (frame) (untracked) = 1.
Stack slot id for offset -16 (-0x10) (frame) (untracked) = 2.
Stack slot id for offset -24 (-0x18) (frame) (untracked) = 3.
Stack slot id for offset -32 (-0x20) (frame) (untracked) = 4.
Stack slot id for offset -40 (-0x28) (frame) (untracked) = 5.
Register slot id for reg rcx = 6.
Register slot id for reg rax = 7.
Register slot id for reg rdx = 8.
Set state of slot 6 at instr offset 0x41 to Live.
Set state of slot 6 at instr offset 0x4f to Dead.
Set state of slot 7 at instr offset 0x59 to Live.
Set state of slot 6 at instr offset 0x74 to Live.
Set state of slot 8 at instr offset 0x78 to Live.
Set state of slot 7 at instr offset 0x7d to Dead.
Set state of slot 6 at instr offset 0x7d to Dead.
Set state of slot 8 at instr offset 0x7d to Dead.
Set state of slot 6 at instr offset 0x81 to Live.
Set state of slot 8 at instr offset 0x8d to Live.
Set state of slot 7 at instr offset 0x99 to Live.
Set state of slot 6 at instr offset 0x99 to Dead.
Set state of slot 8 at instr offset 0x99 to Dead.
Set state of slot 7 at instr offset 0xa5 to Dead.
Defining interruptible range: [0x28, 0x9f).

*************** Finishing PHASE Emit GC+EH tables
Method code size: 165

Allocations for System.Runtime.Intrinsics.X86.Program:Main(System.String[]) (MethodHash=1e684c7a)
count:        877, size:      70258, max =       5304
allocateMemory:     131072, nraUsed:      72976

Alloc'd bytes by kind:
                  kind |       size |     pct
  ---------------------+------------+--------
         AssertionProp |          0 |   0.00%
               ASTNode |       7688 |  10.94%
              InstDesc |       4944 |   7.04%
              ImpStack |        384 |   0.55%
            BasicBlock |       2024 |   2.88%
              CallArgs |        640 |   0.91%
              FlowEdge |        288 |   0.41%
     TreeStatementList |          0 |   0.00%
               SiScope |          0 |   0.00%
       DominatorMemory |          0 |   0.00%
                  LSRA |       7272 |  10.35%
         LSRA_Interval |       1680 |   2.39%
      LSRA_RefPosition |       8720 |  12.41%
          Reachability |        144 |   0.20%
                   SSA |          0 |   0.00%
           ValueNumber |          0 |   0.00%
              LvaTable |       1536 |   2.19%
            UnwindInfo |          0 |   0.00%
                hashBv |         40 |   0.06%
                bitset |         32 |   0.05%
          FixedBitVect |         24 |   0.03%
               Generic |       1524 |   2.17%
   LocalAddressVisitor |          0 |   0.00%
         FieldSeqStore |          0 |   0.00%
          MemorySsaMap |          0 |   0.00%
          MemoryPhiArg |          0 |   0.00%
                   CSE |          0 |   0.00%
                    GC |       3348 |   4.77%
       CorTailCallInfo |          0 |   0.00%
              Inlining |        248 |   0.35%
            ArrayStack |          0 |   0.00%
             DebugInfo |        744 |   1.06%
             DebugOnly |      26767 |  38.10%
               Codegen |       1224 |   1.74%
               LoopOpt |          0 |   0.00%
             LoopClone |          0 |   0.00%
             LoopHoist |          0 |   0.00%
               Unknown |         51 |   0.07%
            RangeCheck |          0 |   0.00%
              CopyProp |          0 |   0.00%
             Promotion |          0 |   0.00%
           SideEffects |          0 |   0.00%
       ObjectAllocator |          0 |   0.00%
    VariableLiveRanges |        760 |   1.08%
           ClassLayout |        176 |   0.25%
       TailMergeThrows |          0 |   0.00%
             EarlyProp |          0 |   0.00%
              ZeroInit |          0 |   0.00%
                   Pgo |          0 |   0.00%

****** DONE compiling System.Runtime.Intrinsics.X86.Program:Main(System.String[])
Vector512.IsHardwareAccelerated: False
Implementing vector128 codepath
